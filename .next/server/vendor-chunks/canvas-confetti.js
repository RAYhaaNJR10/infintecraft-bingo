"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-confetti";
exports.ids = ["vendor-chunks/canvas-confetti"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/canvas-confetti/dist/confetti.module.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// canvas-confetti v1.9.4 built on 2025-10-25T05:14:56.640Z\nvar module = {};\n// source content\n/* globals Map */ (function main(global, module, isWorker, workerSize) {\n    var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);\n    var canUsePaths = typeof Path2D === \"function\" && typeof DOMMatrix === \"function\";\n    var canDrawBitmap = function() {\n        // this mostly supports ssr\n        if (!global.OffscreenCanvas) {\n            return false;\n        }\n        try {\n            var canvas = new OffscreenCanvas(1, 1);\n            var ctx = canvas.getContext(\"2d\");\n            ctx.fillRect(0, 0, 1, 1);\n            var bitmap = canvas.transferToImageBitmap();\n            ctx.createPattern(bitmap, \"no-repeat\");\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }();\n    function noop() {}\n    // create a promise if it exists, otherwise, just\n    // call the function directly\n    function promise(func) {\n        var ModulePromise = module.exports.Promise;\n        var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\n        if (typeof Prom === \"function\") {\n            return new Prom(func);\n        }\n        func(noop, noop);\n        return null;\n    }\n    var bitmapMapper = function(skipTransform, map) {\n        // see https://github.com/catdad/canvas-confetti/issues/209\n        // creating canvases is actually pretty expensive, so we should create a\n        // 1:1 map for bitmap:canvas, so that we can animate the confetti in\n        // a performant manner, but also not store them forever so that we don't\n        // have a memory leak\n        return {\n            transform: function(bitmap) {\n                if (skipTransform) {\n                    return bitmap;\n                }\n                if (map.has(bitmap)) {\n                    return map.get(bitmap);\n                }\n                var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n                var ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0);\n                map.set(bitmap, canvas);\n                return canvas;\n            },\n            clear: function() {\n                map.clear();\n            }\n        };\n    }(canDrawBitmap, new Map());\n    var raf = function() {\n        var TIME = Math.floor(1000 / 60);\n        var frame, cancel;\n        var frames = {};\n        var lastFrameTime = 0;\n        if (typeof requestAnimationFrame === \"function\" && typeof cancelAnimationFrame === \"function\") {\n            frame = function(cb) {\n                var id = Math.random();\n                frames[id] = requestAnimationFrame(function onFrame(time) {\n                    if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\n                        lastFrameTime = time;\n                        delete frames[id];\n                        cb();\n                    } else {\n                        frames[id] = requestAnimationFrame(onFrame);\n                    }\n                });\n                return id;\n            };\n            cancel = function(id) {\n                if (frames[id]) {\n                    cancelAnimationFrame(frames[id]);\n                }\n            };\n        } else {\n            frame = function(cb) {\n                return setTimeout(cb, TIME);\n            };\n            cancel = function(timer) {\n                return clearTimeout(timer);\n            };\n        }\n        return {\n            frame: frame,\n            cancel: cancel\n        };\n    }();\n    var getWorker = function() {\n        var worker;\n        var prom;\n        var resolves = {};\n        function decorate(worker) {\n            function execute(options, callback) {\n                worker.postMessage({\n                    options: options || {},\n                    callback: callback\n                });\n            }\n            worker.init = function initWorker(canvas) {\n                var offscreen = canvas.transferControlToOffscreen();\n                worker.postMessage({\n                    canvas: offscreen\n                }, [\n                    offscreen\n                ]);\n            };\n            worker.fire = function fireWorker(options, size, done) {\n                if (prom) {\n                    execute(options, null);\n                    return prom;\n                }\n                var id = Math.random().toString(36).slice(2);\n                prom = promise(function(resolve) {\n                    function workerDone(msg) {\n                        if (msg.data.callback !== id) {\n                            return;\n                        }\n                        delete resolves[id];\n                        worker.removeEventListener(\"message\", workerDone);\n                        prom = null;\n                        bitmapMapper.clear();\n                        done();\n                        resolve();\n                    }\n                    worker.addEventListener(\"message\", workerDone);\n                    execute(options, id);\n                    resolves[id] = workerDone.bind(null, {\n                        data: {\n                            callback: id\n                        }\n                    });\n                });\n                return prom;\n            };\n            worker.reset = function resetWorker() {\n                worker.postMessage({\n                    reset: true\n                });\n                for(var id in resolves){\n                    resolves[id]();\n                    delete resolves[id];\n                }\n            };\n        }\n        return function() {\n            if (worker) {\n                return worker;\n            }\n            if (!isWorker && canUseWorker) {\n                var code = [\n                    \"var CONFETTI, SIZE = {}, module = {};\",\n                    \"(\" + main.toString() + \")(this, module, true, SIZE);\",\n                    \"onmessage = function(msg) {\",\n                    \"  if (msg.data.options) {\",\n                    \"    CONFETTI(msg.data.options).then(function () {\",\n                    \"      if (msg.data.callback) {\",\n                    \"        postMessage({ callback: msg.data.callback });\",\n                    \"      }\",\n                    \"    });\",\n                    \"  } else if (msg.data.reset) {\",\n                    \"    CONFETTI && CONFETTI.reset();\",\n                    \"  } else if (msg.data.resize) {\",\n                    \"    SIZE.width = msg.data.resize.width;\",\n                    \"    SIZE.height = msg.data.resize.height;\",\n                    \"  } else if (msg.data.canvas) {\",\n                    \"    SIZE.width = msg.data.canvas.width;\",\n                    \"    SIZE.height = msg.data.canvas.height;\",\n                    \"    CONFETTI = module.exports.create(msg.data.canvas);\",\n                    \"  }\",\n                    \"}\"\n                ].join(\"\\n\");\n                try {\n                    worker = new Worker(URL.createObjectURL(new Blob([\n                        code\n                    ])));\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    typeof console !== \"undefined\" && typeof console.warn === \"function\" ? console.warn(\"\\uD83C\\uDF8A Could not load worker\", e) : null;\n                    return null;\n                }\n                decorate(worker);\n            }\n            return worker;\n        };\n    }();\n    var defaults = {\n        particleCount: 50,\n        angle: 90,\n        spread: 45,\n        startVelocity: 45,\n        decay: 0.9,\n        gravity: 1,\n        drift: 0,\n        ticks: 200,\n        x: 0.5,\n        y: 0.5,\n        shapes: [\n            \"square\",\n            \"circle\"\n        ],\n        zIndex: 100,\n        colors: [\n            \"#26ccff\",\n            \"#a25afd\",\n            \"#ff5e7e\",\n            \"#88ff5a\",\n            \"#fcff42\",\n            \"#ffa62d\",\n            \"#ff36ff\"\n        ],\n        // probably should be true, but back-compat\n        disableForReducedMotion: false,\n        scalar: 1\n    };\n    function convert(val, transform) {\n        return transform ? transform(val) : val;\n    }\n    function isOk(val) {\n        return !(val === null || val === undefined);\n    }\n    function prop(options, name, transform) {\n        return convert(options && isOk(options[name]) ? options[name] : defaults[name], transform);\n    }\n    function onlyPositiveInt(number) {\n        return number < 0 ? 0 : Math.floor(number);\n    }\n    function randomInt(min, max) {\n        // [min, max)\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    function toDecimal(str) {\n        return parseInt(str, 16);\n    }\n    function colorsToRgb(colors) {\n        return colors.map(hexToRgb);\n    }\n    function hexToRgb(str) {\n        var val = String(str).replace(/[^0-9a-f]/gi, \"\");\n        if (val.length < 6) {\n            val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\n        }\n        return {\n            r: toDecimal(val.substring(0, 2)),\n            g: toDecimal(val.substring(2, 4)),\n            b: toDecimal(val.substring(4, 6))\n        };\n    }\n    function getOrigin(options) {\n        var origin = prop(options, \"origin\", Object);\n        origin.x = prop(origin, \"x\", Number);\n        origin.y = prop(origin, \"y\", Number);\n        return origin;\n    }\n    function setCanvasWindowSize(canvas) {\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = document.documentElement.clientHeight;\n    }\n    function setCanvasRectSize(canvas) {\n        var rect = canvas.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n    }\n    function getCanvas(zIndex) {\n        var canvas = document.createElement(\"canvas\");\n        canvas.style.position = \"fixed\";\n        canvas.style.top = \"0px\";\n        canvas.style.left = \"0px\";\n        canvas.style.pointerEvents = \"none\";\n        canvas.style.zIndex = zIndex;\n        return canvas;\n    }\n    function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n        context.save();\n        context.translate(x, y);\n        context.rotate(rotation);\n        context.scale(radiusX, radiusY);\n        context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n        context.restore();\n    }\n    function randomPhysics(opts) {\n        var radAngle = opts.angle * (Math.PI / 180);\n        var radSpread = opts.spread * (Math.PI / 180);\n        return {\n            x: opts.x,\n            y: opts.y,\n            wobble: Math.random() * 10,\n            wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\n            velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,\n            angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),\n            tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\n            color: opts.color,\n            shape: opts.shape,\n            tick: 0,\n            totalTicks: opts.ticks,\n            decay: opts.decay,\n            drift: opts.drift,\n            random: Math.random() + 2,\n            tiltSin: 0,\n            tiltCos: 0,\n            wobbleX: 0,\n            wobbleY: 0,\n            gravity: opts.gravity * 3,\n            ovalScalar: 0.6,\n            scalar: opts.scalar,\n            flat: opts.flat\n        };\n    }\n    function updateFetti(context, fetti) {\n        fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\n        fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\n        fetti.velocity *= fetti.decay;\n        if (fetti.flat) {\n            fetti.wobble = 0;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar;\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar;\n            fetti.tiltSin = 0;\n            fetti.tiltCos = 0;\n            fetti.random = 1;\n        } else {\n            fetti.wobble += fetti.wobbleSpeed;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);\n            fetti.tiltAngle += 0.1;\n            fetti.tiltSin = Math.sin(fetti.tiltAngle);\n            fetti.tiltCos = Math.cos(fetti.tiltAngle);\n            fetti.random = Math.random() + 2;\n        }\n        var progress = fetti.tick++ / fetti.totalTicks;\n        var x1 = fetti.x + fetti.random * fetti.tiltCos;\n        var y1 = fetti.y + fetti.random * fetti.tiltSin;\n        var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;\n        var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;\n        context.fillStyle = \"rgba(\" + fetti.color.r + \", \" + fetti.color.g + \", \" + fetti.color.b + \", \" + (1 - progress) + \")\";\n        context.beginPath();\n        if (canUsePaths && fetti.shape.type === \"path\" && typeof fetti.shape.path === \"string\" && Array.isArray(fetti.shape.matrix)) {\n            context.fill(transformPath2D(fetti.shape.path, fetti.shape.matrix, fetti.x, fetti.y, Math.abs(x2 - x1) * 0.1, Math.abs(y2 - y1) * 0.1, Math.PI / 10 * fetti.wobble));\n        } else if (fetti.shape.type === \"bitmap\") {\n            var rotation = Math.PI / 10 * fetti.wobble;\n            var scaleX = Math.abs(x2 - x1) * 0.1;\n            var scaleY = Math.abs(y2 - y1) * 0.1;\n            var width = fetti.shape.bitmap.width * fetti.scalar;\n            var height = fetti.shape.bitmap.height * fetti.scalar;\n            var matrix = new DOMMatrix([\n                Math.cos(rotation) * scaleX,\n                Math.sin(rotation) * scaleX,\n                -Math.sin(rotation) * scaleY,\n                Math.cos(rotation) * scaleY,\n                fetti.x,\n                fetti.y\n            ]);\n            // apply the transform matrix from the confetti shape\n            matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));\n            var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), \"no-repeat\");\n            pattern.setTransform(matrix);\n            context.globalAlpha = 1 - progress;\n            context.fillStyle = pattern;\n            context.fillRect(fetti.x - width / 2, fetti.y - height / 2, width, height);\n            context.globalAlpha = 1;\n        } else if (fetti.shape === \"circle\") {\n            context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\n        } else if (fetti.shape === \"star\") {\n            var rot = Math.PI / 2 * 3;\n            var innerRadius = 4 * fetti.scalar;\n            var outerRadius = 8 * fetti.scalar;\n            var x = fetti.x;\n            var y = fetti.y;\n            var spikes = 5;\n            var step = Math.PI / spikes;\n            while(spikes--){\n                x = fetti.x + Math.cos(rot) * outerRadius;\n                y = fetti.y + Math.sin(rot) * outerRadius;\n                context.lineTo(x, y);\n                rot += step;\n                x = fetti.x + Math.cos(rot) * innerRadius;\n                y = fetti.y + Math.sin(rot) * innerRadius;\n                context.lineTo(x, y);\n                rot += step;\n            }\n        } else {\n            context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\n            context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\n            context.lineTo(Math.floor(x2), Math.floor(y2));\n            context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\n        }\n        context.closePath();\n        context.fill();\n        return fetti.tick < fetti.totalTicks;\n    }\n    function animate(canvas, fettis, resizer, size, done) {\n        var animatingFettis = fettis.slice();\n        var context = canvas.getContext(\"2d\");\n        var animationFrame;\n        var destroy;\n        var prom = promise(function(resolve) {\n            function onDone() {\n                animationFrame = destroy = null;\n                context.clearRect(0, 0, size.width, size.height);\n                bitmapMapper.clear();\n                done();\n                resolve();\n            }\n            function update() {\n                if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\n                    size.width = canvas.width = workerSize.width;\n                    size.height = canvas.height = workerSize.height;\n                }\n                if (!size.width && !size.height) {\n                    resizer(canvas);\n                    size.width = canvas.width;\n                    size.height = canvas.height;\n                }\n                context.clearRect(0, 0, size.width, size.height);\n                animatingFettis = animatingFettis.filter(function(fetti) {\n                    return updateFetti(context, fetti);\n                });\n                if (animatingFettis.length) {\n                    animationFrame = raf.frame(update);\n                } else {\n                    onDone();\n                }\n            }\n            animationFrame = raf.frame(update);\n            destroy = onDone;\n        });\n        return {\n            addFettis: function(fettis) {\n                animatingFettis = animatingFettis.concat(fettis);\n                return prom;\n            },\n            canvas: canvas,\n            promise: prom,\n            reset: function() {\n                if (animationFrame) {\n                    raf.cancel(animationFrame);\n                }\n                if (destroy) {\n                    destroy();\n                }\n            }\n        };\n    }\n    function confettiCannon(canvas, globalOpts) {\n        var isLibCanvas = !canvas;\n        var allowResize = !!prop(globalOpts || {}, \"resize\");\n        var hasResizeEventRegistered = false;\n        var globalDisableForReducedMotion = prop(globalOpts, \"disableForReducedMotion\", Boolean);\n        var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, \"useWorker\");\n        var worker = shouldUseWorker ? getWorker() : null;\n        var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\n        var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;\n        var preferLessMotion = typeof matchMedia === \"function\" && matchMedia(\"(prefers-reduced-motion)\").matches;\n        var animationObj;\n        function fireLocal(options, size, done) {\n            var particleCount = prop(options, \"particleCount\", onlyPositiveInt);\n            var angle = prop(options, \"angle\", Number);\n            var spread = prop(options, \"spread\", Number);\n            var startVelocity = prop(options, \"startVelocity\", Number);\n            var decay = prop(options, \"decay\", Number);\n            var gravity = prop(options, \"gravity\", Number);\n            var drift = prop(options, \"drift\", Number);\n            var colors = prop(options, \"colors\", colorsToRgb);\n            var ticks = prop(options, \"ticks\", Number);\n            var shapes = prop(options, \"shapes\");\n            var scalar = prop(options, \"scalar\");\n            var flat = !!prop(options, \"flat\");\n            var origin = getOrigin(options);\n            var temp = particleCount;\n            var fettis = [];\n            var startX = canvas.width * origin.x;\n            var startY = canvas.height * origin.y;\n            while(temp--){\n                fettis.push(randomPhysics({\n                    x: startX,\n                    y: startY,\n                    angle: angle,\n                    spread: spread,\n                    startVelocity: startVelocity,\n                    color: colors[temp % colors.length],\n                    shape: shapes[randomInt(0, shapes.length)],\n                    ticks: ticks,\n                    decay: decay,\n                    gravity: gravity,\n                    drift: drift,\n                    scalar: scalar,\n                    flat: flat\n                }));\n            }\n            // if we have a previous canvas already animating,\n            // add to it\n            if (animationObj) {\n                return animationObj.addFettis(fettis);\n            }\n            animationObj = animate(canvas, fettis, resizer, size, done);\n            return animationObj.promise;\n        }\n        function fire(options) {\n            var disableForReducedMotion = globalDisableForReducedMotion || prop(options, \"disableForReducedMotion\", Boolean);\n            var zIndex = prop(options, \"zIndex\", Number);\n            if (disableForReducedMotion && preferLessMotion) {\n                return promise(function(resolve) {\n                    resolve();\n                });\n            }\n            if (isLibCanvas && animationObj) {\n                // use existing canvas from in-progress animation\n                canvas = animationObj.canvas;\n            } else if (isLibCanvas && !canvas) {\n                // create and initialize a new canvas\n                canvas = getCanvas(zIndex);\n                document.body.appendChild(canvas);\n            }\n            if (allowResize && !initialized) {\n                // initialize the size of a user-supplied canvas\n                resizer(canvas);\n            }\n            var size = {\n                width: canvas.width,\n                height: canvas.height\n            };\n            if (worker && !initialized) {\n                worker.init(canvas);\n            }\n            initialized = true;\n            if (worker) {\n                canvas.__confetti_initialized = true;\n            }\n            function onResize() {\n                if (worker) {\n                    // TODO this really shouldn't be immediate, because it is expensive\n                    var obj = {\n                        getBoundingClientRect: function() {\n                            if (!isLibCanvas) {\n                                return canvas.getBoundingClientRect();\n                            }\n                        }\n                    };\n                    resizer(obj);\n                    worker.postMessage({\n                        resize: {\n                            width: obj.width,\n                            height: obj.height\n                        }\n                    });\n                    return;\n                }\n                // don't actually query the size here, since this\n                // can execute frequently and rapidly\n                size.width = size.height = null;\n            }\n            function done() {\n                animationObj = null;\n                if (allowResize) {\n                    hasResizeEventRegistered = false;\n                    global.removeEventListener(\"resize\", onResize);\n                }\n                if (isLibCanvas && canvas) {\n                    if (document.body.contains(canvas)) {\n                        document.body.removeChild(canvas);\n                    }\n                    canvas = null;\n                    initialized = false;\n                }\n            }\n            if (allowResize && !hasResizeEventRegistered) {\n                hasResizeEventRegistered = true;\n                global.addEventListener(\"resize\", onResize, false);\n            }\n            if (worker) {\n                return worker.fire(options, size, done);\n            }\n            return fireLocal(options, size, done);\n        }\n        fire.reset = function() {\n            if (worker) {\n                worker.reset();\n            }\n            if (animationObj) {\n                animationObj.reset();\n            }\n        };\n        return fire;\n    }\n    // Make default export lazy to defer worker creation until called.\n    var defaultFire;\n    function getDefaultFire() {\n        if (!defaultFire) {\n            defaultFire = confettiCannon(null, {\n                useWorker: true,\n                resize: true\n            });\n        }\n        return defaultFire;\n    }\n    function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {\n        var path2d = new Path2D(pathString);\n        var t1 = new Path2D();\n        t1.addPath(path2d, new DOMMatrix(pathMatrix));\n        var t2 = new Path2D();\n        // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix\n        t2.addPath(t1, new DOMMatrix([\n            Math.cos(rotation) * scaleX,\n            Math.sin(rotation) * scaleX,\n            -Math.sin(rotation) * scaleY,\n            Math.cos(rotation) * scaleY,\n            x,\n            y\n        ]));\n        return t2;\n    }\n    function shapeFromPath(pathData) {\n        if (!canUsePaths) {\n            throw new Error(\"path confetti are not supported in this browser\");\n        }\n        var path, matrix;\n        if (typeof pathData === \"string\") {\n            path = pathData;\n        } else {\n            path = pathData.path;\n            matrix = pathData.matrix;\n        }\n        var path2d = new Path2D(path);\n        var tempCanvas = document.createElement(\"canvas\");\n        var tempCtx = tempCanvas.getContext(\"2d\");\n        if (!matrix) {\n            // attempt to figure out the width of the path, up to 1000x1000\n            var maxSize = 1000;\n            var minX = maxSize;\n            var minY = maxSize;\n            var maxX = 0;\n            var maxY = 0;\n            var width, height;\n            // do some line skipping... this is faster than checking\n            // every pixel and will be mostly still correct\n            for(var x = 0; x < maxSize; x += 2){\n                for(var y = 0; y < maxSize; y += 2){\n                    if (tempCtx.isPointInPath(path2d, x, y, \"nonzero\")) {\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            width = maxX - minX;\n            height = maxY - minY;\n            var maxDesiredSize = 10;\n            var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);\n            matrix = [\n                scale,\n                0,\n                0,\n                scale,\n                -Math.round(width / 2 + minX) * scale,\n                -Math.round(height / 2 + minY) * scale\n            ];\n        }\n        return {\n            type: \"path\",\n            path: path,\n            matrix: matrix\n        };\n    }\n    function shapeFromText(textData) {\n        var text, scalar = 1, color = \"#000000\", // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/\n        fontFamily = '\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\", \"EmojiOne Color\", \"Android Emoji\", \"Twemoji Mozilla\", \"system emoji\", sans-serif';\n        if (typeof textData === \"string\") {\n            text = textData;\n        } else {\n            text = textData.text;\n            scalar = \"scalar\" in textData ? textData.scalar : scalar;\n            fontFamily = \"fontFamily\" in textData ? textData.fontFamily : fontFamily;\n            color = \"color\" in textData ? textData.color : color;\n        }\n        // all other confetti are 10 pixels,\n        // so this pixel size is the de-facto 100% scale confetti\n        var fontSize = 10 * scalar;\n        var font = \"\" + fontSize + \"px \" + fontFamily;\n        var canvas = new OffscreenCanvas(fontSize, fontSize);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        var size = ctx.measureText(text);\n        var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);\n        var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);\n        var padding = 2;\n        var x = size.actualBoundingBoxLeft + padding;\n        var y = size.actualBoundingBoxAscent + padding;\n        width += padding + padding;\n        height += padding + padding;\n        canvas = new OffscreenCanvas(width, height);\n        ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n        var scale = 1 / scalar;\n        return {\n            type: \"bitmap\",\n            // TODO these probably need to be transfered for workers\n            bitmap: canvas.transferToImageBitmap(),\n            matrix: [\n                scale,\n                0,\n                0,\n                scale,\n                -width * scale / 2,\n                -height * scale / 2\n            ]\n        };\n    }\n    module.exports = function() {\n        return getDefaultFire().apply(this, arguments);\n    };\n    module.exports.reset = function() {\n        getDefaultFire().reset();\n    };\n    module.exports.create = confettiCannon;\n    module.exports.shapeFromPath = shapeFromPath;\n    module.exports.shapeFromText = shapeFromText;\n})(function() {\n    if (false) {}\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return this || {};\n}(), module, false);\n// end source content\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);\nvar create = module.exports.create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJEQUEyRDtBQUMzRCxJQUFJQSxTQUFTLENBQUM7QUFFZCxpQkFBaUI7QUFDakIsZUFBZSxHQUVkLFVBQVNDLEtBQUtDLE1BQU0sRUFBRUYsTUFBTSxFQUFFRyxRQUFRLEVBQUVDLFVBQVU7SUFDakQsSUFBSUMsZUFBZSxDQUFDLENBQ2xCSCxDQUFBQSxPQUFPSSxNQUFNLElBQ2JKLE9BQU9LLElBQUksSUFDWEwsT0FBT00sT0FBTyxJQUNkTixPQUFPTyxlQUFlLElBQ3RCUCxPQUFPUSxpQ0FBaUMsSUFDeENSLE9BQU9TLGlCQUFpQixJQUN4QlQsT0FBT1MsaUJBQWlCLENBQUNDLFNBQVMsQ0FBQ0MsMEJBQTBCLElBQzdEWCxPQUFPWSxHQUFHLElBQ1ZaLE9BQU9ZLEdBQUcsQ0FBQ0MsZUFBZTtJQUU1QixJQUFJQyxjQUFjLE9BQU9DLFdBQVcsY0FBYyxPQUFPQyxjQUFjO0lBQ3ZFLElBQUlDLGdCQUFnQjtRQUNsQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDakIsT0FBT08sZUFBZSxFQUFFO1lBQzNCLE9BQU87UUFDVDtRQUVBLElBQUk7WUFDRixJQUFJVyxTQUFTLElBQUlYLGdCQUFnQixHQUFHO1lBQ3BDLElBQUlZLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQztZQUM1QkQsSUFBSUUsUUFBUSxDQUFDLEdBQUcsR0FBRyxHQUFHO1lBQ3RCLElBQUlDLFNBQVNKLE9BQU9LLHFCQUFxQjtZQUN6Q0osSUFBSUssYUFBYSxDQUFDRixRQUFRO1FBQzVCLEVBQUUsT0FBT0csR0FBRztZQUNWLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBLFNBQVNDLFFBQVE7SUFFakIsaURBQWlEO0lBQ2pELDZCQUE2QjtJQUM3QixTQUFTQyxRQUFRQyxJQUFJO1FBQ25CLElBQUlDLGdCQUFnQi9CLE9BQU9nQyxPQUFPLENBQUN4QixPQUFPO1FBQzFDLElBQUl5QixPQUFPRixrQkFBa0IsS0FBSyxJQUFJQSxnQkFBZ0I3QixPQUFPTSxPQUFPO1FBRXBFLElBQUksT0FBT3lCLFNBQVMsWUFBWTtZQUM5QixPQUFPLElBQUlBLEtBQUtIO1FBQ2xCO1FBRUFBLEtBQUtGLE1BQU1BO1FBRVgsT0FBTztJQUNUO0lBRUEsSUFBSU0sZUFBZSxTQUFXQyxhQUFhLEVBQUVDLEdBQUc7UUFDOUMsMkRBQTJEO1FBQzNELHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEUsd0VBQXdFO1FBQ3hFLHFCQUFxQjtRQUNyQixPQUFPO1lBQ0xDLFdBQVcsU0FBU2IsTUFBTTtnQkFDeEIsSUFBSVcsZUFBZTtvQkFDakIsT0FBT1g7Z0JBQ1Q7Z0JBRUEsSUFBSVksSUFBSUUsR0FBRyxDQUFDZCxTQUFTO29CQUNuQixPQUFPWSxJQUFJRyxHQUFHLENBQUNmO2dCQUNqQjtnQkFFQSxJQUFJSixTQUFTLElBQUlYLGdCQUFnQmUsT0FBT2dCLEtBQUssRUFBRWhCLE9BQU9pQixNQUFNO2dCQUM1RCxJQUFJcEIsTUFBTUQsT0FBT0UsVUFBVSxDQUFDO2dCQUM1QkQsSUFBSXFCLFNBQVMsQ0FBQ2xCLFFBQVEsR0FBRztnQkFFekJZLElBQUlPLEdBQUcsQ0FBQ25CLFFBQVFKO2dCQUVoQixPQUFPQTtZQUNUO1lBQ0F3QixPQUFPO2dCQUNMUixJQUFJUSxLQUFLO1lBQ1g7UUFDRjtJQUNGLEVBQUd6QixlQUFlLElBQUkwQjtJQUV0QixJQUFJQyxNQUFPO1FBQ1QsSUFBSUMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDLE9BQU87UUFDN0IsSUFBSUMsT0FBT0M7UUFDWCxJQUFJQyxTQUFTLENBQUM7UUFDZCxJQUFJQyxnQkFBZ0I7UUFFcEIsSUFBSSxPQUFPQywwQkFBMEIsY0FBYyxPQUFPQyx5QkFBeUIsWUFBWTtZQUM3RkwsUUFBUSxTQUFVTSxFQUFFO2dCQUNsQixJQUFJQyxLQUFLVCxLQUFLVSxNQUFNO2dCQUVwQk4sTUFBTSxDQUFDSyxHQUFHLEdBQUdILHNCQUFzQixTQUFTSyxRQUFRQyxJQUFJO29CQUN0RCxJQUFJUCxrQkFBa0JPLFFBQVFQLGdCQUFnQk4sT0FBTyxJQUFJYSxNQUFNO3dCQUM3RFAsZ0JBQWdCTzt3QkFDaEIsT0FBT1IsTUFBTSxDQUFDSyxHQUFHO3dCQUVqQkQ7b0JBQ0YsT0FBTzt3QkFDTEosTUFBTSxDQUFDSyxHQUFHLEdBQUdILHNCQUFzQks7b0JBQ3JDO2dCQUNGO2dCQUVBLE9BQU9GO1lBQ1Q7WUFDQU4sU0FBUyxTQUFVTSxFQUFFO2dCQUNuQixJQUFJTCxNQUFNLENBQUNLLEdBQUcsRUFBRTtvQkFDZEYscUJBQXFCSCxNQUFNLENBQUNLLEdBQUc7Z0JBQ2pDO1lBQ0Y7UUFDRixPQUFPO1lBQ0xQLFFBQVEsU0FBVU0sRUFBRTtnQkFDbEIsT0FBT0ssV0FBV0wsSUFBSVQ7WUFDeEI7WUFDQUksU0FBUyxTQUFVVyxLQUFLO2dCQUN0QixPQUFPQyxhQUFhRDtZQUN0QjtRQUNGO1FBRUEsT0FBTztZQUFFWixPQUFPQTtZQUFPQyxRQUFRQTtRQUFPO0lBQ3hDO0lBRUEsSUFBSWEsWUFBWTtRQUNkLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQyxXQUFXLENBQUM7UUFFaEIsU0FBU0MsU0FBU0gsTUFBTTtZQUN0QixTQUFTSSxRQUFRQyxPQUFPLEVBQUVDLFFBQVE7Z0JBQ2hDTixPQUFPTyxXQUFXLENBQUM7b0JBQUVGLFNBQVNBLFdBQVcsQ0FBQztvQkFBR0MsVUFBVUE7Z0JBQVM7WUFDbEU7WUFDQU4sT0FBT1EsSUFBSSxHQUFHLFNBQVNDLFdBQVd0RCxNQUFNO2dCQUN0QyxJQUFJdUQsWUFBWXZELE9BQU9QLDBCQUEwQjtnQkFDakRvRCxPQUFPTyxXQUFXLENBQUM7b0JBQUVwRCxRQUFRdUQ7Z0JBQVUsR0FBRztvQkFBQ0E7aUJBQVU7WUFDdkQ7WUFFQVYsT0FBT1csSUFBSSxHQUFHLFNBQVNDLFdBQVdQLE9BQU8sRUFBRVEsSUFBSSxFQUFFQyxJQUFJO2dCQUNuRCxJQUFJYixNQUFNO29CQUNSRyxRQUFRQyxTQUFTO29CQUNqQixPQUFPSjtnQkFDVDtnQkFFQSxJQUFJVCxLQUFLVCxLQUFLVSxNQUFNLEdBQUdzQixRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDO2dCQUUxQ2YsT0FBT3JDLFFBQVEsU0FBVXFELE9BQU87b0JBQzlCLFNBQVNDLFdBQVdDLEdBQUc7d0JBQ3JCLElBQUlBLElBQUlDLElBQUksQ0FBQ2QsUUFBUSxLQUFLZCxJQUFJOzRCQUM1Qjt3QkFDRjt3QkFFQSxPQUFPVSxRQUFRLENBQUNWLEdBQUc7d0JBQ25CUSxPQUFPcUIsbUJBQW1CLENBQUMsV0FBV0g7d0JBRXRDakIsT0FBTzt3QkFFUGhDLGFBQWFVLEtBQUs7d0JBRWxCbUM7d0JBQ0FHO29CQUNGO29CQUVBakIsT0FBT3NCLGdCQUFnQixDQUFDLFdBQVdKO29CQUNuQ2QsUUFBUUMsU0FBU2I7b0JBRWpCVSxRQUFRLENBQUNWLEdBQUcsR0FBRzBCLFdBQVdLLElBQUksQ0FBQyxNQUFNO3dCQUFFSCxNQUFNOzRCQUFFZCxVQUFVZDt3QkFBRztvQkFBQztnQkFDL0Q7Z0JBRUEsT0FBT1M7WUFDVDtZQUVBRCxPQUFPd0IsS0FBSyxHQUFHLFNBQVNDO2dCQUN0QnpCLE9BQU9PLFdBQVcsQ0FBQztvQkFBRWlCLE9BQU87Z0JBQUs7Z0JBRWpDLElBQUssSUFBSWhDLE1BQU1VLFNBQVU7b0JBQ3ZCQSxRQUFRLENBQUNWLEdBQUc7b0JBQ1osT0FBT1UsUUFBUSxDQUFDVixHQUFHO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPO1lBQ0wsSUFBSVEsUUFBUTtnQkFDVixPQUFPQTtZQUNUO1lBRUEsSUFBSSxDQUFDOUQsWUFBWUUsY0FBYztnQkFDN0IsSUFBSXNGLE9BQU87b0JBQ1Q7b0JBQ0EsTUFBTTFGLEtBQUsrRSxRQUFRLEtBQUs7b0JBQ3hCO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO29CQUNBO2lCQUNELENBQUNZLElBQUksQ0FBQztnQkFDUCxJQUFJO29CQUNGM0IsU0FBUyxJQUFJM0QsT0FBT1EsSUFBSUMsZUFBZSxDQUFDLElBQUlSLEtBQUs7d0JBQUNvRjtxQkFBSztnQkFDekQsRUFBRSxPQUFPaEUsR0FBRztvQkFDVixzQ0FBc0M7b0JBQ3RDLE9BQU9rRSxZQUFZLGVBQWUsT0FBT0EsUUFBUUMsSUFBSSxLQUFLLGFBQWFELFFBQVFDLElBQUksQ0FBQyxzQ0FBNEJuRSxLQUFLO29CQUVySCxPQUFPO2dCQUNUO2dCQUVBeUMsU0FBU0g7WUFDWDtZQUVBLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLElBQUk4QixXQUFXO1FBQ2JDLGVBQWU7UUFDZkMsT0FBTztRQUNQQyxRQUFRO1FBQ1JDLGVBQWU7UUFDZkMsT0FBTztRQUNQQyxTQUFTO1FBQ1RDLE9BQU87UUFDUEMsT0FBTztRQUNQQyxHQUFHO1FBQ0hDLEdBQUc7UUFDSEMsUUFBUTtZQUFDO1lBQVU7U0FBUztRQUM1QkMsUUFBUTtRQUNSQyxRQUFRO1lBQ047WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNELDJDQUEyQztRQUMzQ0MseUJBQXlCO1FBQ3pCQyxRQUFRO0lBQ1Y7SUFFQSxTQUFTQyxRQUFRQyxHQUFHLEVBQUUzRSxTQUFTO1FBQzdCLE9BQU9BLFlBQVlBLFVBQVUyRSxPQUFPQTtJQUN0QztJQUVBLFNBQVNDLEtBQUtELEdBQUc7UUFDZixPQUFPLENBQUVBLENBQUFBLFFBQVEsUUFBUUEsUUFBUUUsU0FBUTtJQUMzQztJQUVBLFNBQVNDLEtBQUs3QyxPQUFPLEVBQUU4QyxJQUFJLEVBQUUvRSxTQUFTO1FBQ3BDLE9BQU8wRSxRQUNMekMsV0FBVzJDLEtBQUszQyxPQUFPLENBQUM4QyxLQUFLLElBQUk5QyxPQUFPLENBQUM4QyxLQUFLLEdBQUdyQixRQUFRLENBQUNxQixLQUFLLEVBQy9EL0U7SUFFSjtJQUVBLFNBQVNnRixnQkFBZ0JDLE1BQU07UUFDN0IsT0FBT0EsU0FBUyxJQUFJLElBQUl0RSxLQUFLQyxLQUFLLENBQUNxRTtJQUNyQztJQUVBLFNBQVNDLFVBQVVDLEdBQUcsRUFBRUMsR0FBRztRQUN6QixhQUFhO1FBQ2IsT0FBT3pFLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS1UsTUFBTSxLQUFNK0QsQ0FBQUEsTUFBTUQsR0FBRSxLQUFNQTtJQUNuRDtJQUVBLFNBQVNFLFVBQVVDLEdBQUc7UUFDcEIsT0FBT0MsU0FBU0QsS0FBSztJQUN2QjtJQUVBLFNBQVNFLFlBQVlqQixNQUFNO1FBQ3pCLE9BQU9BLE9BQU94RSxHQUFHLENBQUMwRjtJQUNwQjtJQUVBLFNBQVNBLFNBQVNILEdBQUc7UUFDbkIsSUFBSVgsTUFBTWUsT0FBT0osS0FBS0ssT0FBTyxDQUFDLGVBQWU7UUFFN0MsSUFBSWhCLElBQUlpQixNQUFNLEdBQUcsR0FBRztZQUNoQmpCLE1BQU1BLEdBQUcsQ0FBQyxFQUFFLEdBQUNBLEdBQUcsQ0FBQyxFQUFFLEdBQUNBLEdBQUcsQ0FBQyxFQUFFLEdBQUNBLEdBQUcsQ0FBQyxFQUFFLEdBQUNBLEdBQUcsQ0FBQyxFQUFFLEdBQUNBLEdBQUcsQ0FBQyxFQUFFO1FBQ25EO1FBRUEsT0FBTztZQUNMa0IsR0FBR1IsVUFBVVYsSUFBSW1CLFNBQVMsQ0FBQyxHQUFFO1lBQzdCQyxHQUFHVixVQUFVVixJQUFJbUIsU0FBUyxDQUFDLEdBQUU7WUFDN0JFLEdBQUdYLFVBQVVWLElBQUltQixTQUFTLENBQUMsR0FBRTtRQUMvQjtJQUNGO0lBRUEsU0FBU0csVUFBVWhFLE9BQU87UUFDeEIsSUFBSWlFLFNBQVNwQixLQUFLN0MsU0FBUyxVQUFVa0U7UUFDckNELE9BQU8vQixDQUFDLEdBQUdXLEtBQUtvQixRQUFRLEtBQUtFO1FBQzdCRixPQUFPOUIsQ0FBQyxHQUFHVSxLQUFLb0IsUUFBUSxLQUFLRTtRQUU3QixPQUFPRjtJQUNUO0lBRUEsU0FBU0csb0JBQW9CdEgsTUFBTTtRQUNqQ0EsT0FBT29CLEtBQUssR0FBR21HLFNBQVNDLGVBQWUsQ0FBQ0MsV0FBVztRQUNuRHpILE9BQU9xQixNQUFNLEdBQUdrRyxTQUFTQyxlQUFlLENBQUNFLFlBQVk7SUFDdkQ7SUFFQSxTQUFTQyxrQkFBa0IzSCxNQUFNO1FBQy9CLElBQUk0SCxPQUFPNUgsT0FBTzZILHFCQUFxQjtRQUN2QzdILE9BQU9vQixLQUFLLEdBQUd3RyxLQUFLeEcsS0FBSztRQUN6QnBCLE9BQU9xQixNQUFNLEdBQUd1RyxLQUFLdkcsTUFBTTtJQUM3QjtJQUVBLFNBQVN5RyxVQUFVdkMsTUFBTTtRQUN2QixJQUFJdkYsU0FBU3VILFNBQVNRLGFBQWEsQ0FBQztRQUVwQy9ILE9BQU9nSSxLQUFLLENBQUNDLFFBQVEsR0FBRztRQUN4QmpJLE9BQU9nSSxLQUFLLENBQUNFLEdBQUcsR0FBRztRQUNuQmxJLE9BQU9nSSxLQUFLLENBQUNHLElBQUksR0FBRztRQUNwQm5JLE9BQU9nSSxLQUFLLENBQUNJLGFBQWEsR0FBRztRQUM3QnBJLE9BQU9nSSxLQUFLLENBQUN6QyxNQUFNLEdBQUdBO1FBRXRCLE9BQU92RjtJQUNUO0lBRUEsU0FBU3FJLFFBQVFDLE9BQU8sRUFBRWxELENBQUMsRUFBRUMsQ0FBQyxFQUFFa0QsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7UUFDN0ZOLFFBQVFPLElBQUk7UUFDWlAsUUFBUVEsU0FBUyxDQUFDMUQsR0FBR0M7UUFDckJpRCxRQUFRUyxNQUFNLENBQUNOO1FBQ2ZILFFBQVFVLEtBQUssQ0FBQ1QsU0FBU0M7UUFDdkJGLFFBQVFXLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBR1AsWUFBWUMsVUFBVUM7UUFDM0NOLFFBQVFZLE9BQU87SUFDakI7SUFFQSxTQUFTQyxjQUFjQyxJQUFJO1FBQ3pCLElBQUlDLFdBQVdELEtBQUt2RSxLQUFLLEdBQUlqRCxDQUFBQSxLQUFLMEgsRUFBRSxHQUFHLEdBQUU7UUFDekMsSUFBSUMsWUFBWUgsS0FBS3RFLE1BQU0sR0FBSWxELENBQUFBLEtBQUswSCxFQUFFLEdBQUcsR0FBRTtRQUUzQyxPQUFPO1lBQ0xsRSxHQUFHZ0UsS0FBS2hFLENBQUM7WUFDVEMsR0FBRytELEtBQUsvRCxDQUFDO1lBQ1RtRSxRQUFRNUgsS0FBS1UsTUFBTSxLQUFLO1lBQ3hCbUgsYUFBYTdILEtBQUt3RSxHQUFHLENBQUMsTUFBTXhFLEtBQUtVLE1BQU0sS0FBSyxNQUFNO1lBQ2xEb0gsVUFBVSxLQUFNM0UsYUFBYSxHQUFHLE1BQVFuRCxLQUFLVSxNQUFNLEtBQUs4RyxLQUFLckUsYUFBYTtZQUMxRTRFLFNBQVMsQ0FBQ04sV0FBWSxPQUFPRSxZQUFjM0gsS0FBS1UsTUFBTSxLQUFLaUgsU0FBUztZQUNwRUssV0FBVyxDQUFDaEksS0FBS1UsTUFBTSxLQUFNLFFBQU8sSUFBRyxJQUFLLElBQUcsSUFBS1YsS0FBSzBILEVBQUU7WUFDM0RPLE9BQU9ULEtBQUtTLEtBQUs7WUFDakJDLE9BQU9WLEtBQUtVLEtBQUs7WUFDakJDLE1BQU07WUFDTkMsWUFBWVosS0FBS2pFLEtBQUs7WUFDdEJILE9BQU9vRSxLQUFLcEUsS0FBSztZQUNqQkUsT0FBT2tFLEtBQUtsRSxLQUFLO1lBQ2pCNUMsUUFBUVYsS0FBS1UsTUFBTSxLQUFLO1lBQ3hCMkgsU0FBUztZQUNUQyxTQUFTO1lBQ1RDLFNBQVM7WUFDVEMsU0FBUztZQUNUbkYsU0FBU21FLEtBQUtuRSxPQUFPLEdBQUc7WUFDeEJvRixZQUFZO1lBQ1ozRSxRQUFRMEQsS0FBSzFELE1BQU07WUFDbkI0RSxNQUFNbEIsS0FBS2tCLElBQUk7UUFDakI7SUFDRjtJQUVBLFNBQVNDLFlBQVlqQyxPQUFPLEVBQUVrQyxLQUFLO1FBQ2pDQSxNQUFNcEYsQ0FBQyxJQUFJeEQsS0FBSzZJLEdBQUcsQ0FBQ0QsTUFBTWIsT0FBTyxJQUFJYSxNQUFNZCxRQUFRLEdBQUdjLE1BQU10RixLQUFLO1FBQ2pFc0YsTUFBTW5GLENBQUMsSUFBSXpELEtBQUs4SSxHQUFHLENBQUNGLE1BQU1iLE9BQU8sSUFBSWEsTUFBTWQsUUFBUSxHQUFHYyxNQUFNdkYsT0FBTztRQUNuRXVGLE1BQU1kLFFBQVEsSUFBSWMsTUFBTXhGLEtBQUs7UUFFN0IsSUFBSXdGLE1BQU1GLElBQUksRUFBRTtZQUNkRSxNQUFNaEIsTUFBTSxHQUFHO1lBQ2ZnQixNQUFNTCxPQUFPLEdBQUdLLE1BQU1wRixDQUFDLEdBQUksS0FBS29GLE1BQU05RSxNQUFNO1lBQzVDOEUsTUFBTUosT0FBTyxHQUFHSSxNQUFNbkYsQ0FBQyxHQUFJLEtBQUttRixNQUFNOUUsTUFBTTtZQUU1QzhFLE1BQU1QLE9BQU8sR0FBRztZQUNoQk8sTUFBTU4sT0FBTyxHQUFHO1lBQ2hCTSxNQUFNbEksTUFBTSxHQUFHO1FBQ2pCLE9BQU87WUFDTGtJLE1BQU1oQixNQUFNLElBQUlnQixNQUFNZixXQUFXO1lBQ2pDZSxNQUFNTCxPQUFPLEdBQUdLLE1BQU1wRixDQUFDLEdBQUksS0FBTW9GLE1BQU05RSxNQUFNLEdBQUk5RCxLQUFLNkksR0FBRyxDQUFDRCxNQUFNaEIsTUFBTTtZQUN0RWdCLE1BQU1KLE9BQU8sR0FBR0ksTUFBTW5GLENBQUMsR0FBSSxLQUFNbUYsTUFBTTlFLE1BQU0sR0FBSTlELEtBQUs4SSxHQUFHLENBQUNGLE1BQU1oQixNQUFNO1lBRXRFZ0IsTUFBTVosU0FBUyxJQUFJO1lBQ25CWSxNQUFNUCxPQUFPLEdBQUdySSxLQUFLOEksR0FBRyxDQUFDRixNQUFNWixTQUFTO1lBQ3hDWSxNQUFNTixPQUFPLEdBQUd0SSxLQUFLNkksR0FBRyxDQUFDRCxNQUFNWixTQUFTO1lBQ3hDWSxNQUFNbEksTUFBTSxHQUFHVixLQUFLVSxNQUFNLEtBQUs7UUFDakM7UUFFQSxJQUFJcUksV0FBVyxNQUFPWixJQUFJLEtBQU1TLE1BQU1SLFVBQVU7UUFFaEQsSUFBSVksS0FBS0osTUFBTXBGLENBQUMsR0FBSW9GLE1BQU1sSSxNQUFNLEdBQUdrSSxNQUFNTixPQUFPO1FBQ2hELElBQUlXLEtBQUtMLE1BQU1uRixDQUFDLEdBQUltRixNQUFNbEksTUFBTSxHQUFHa0ksTUFBTVAsT0FBTztRQUNoRCxJQUFJYSxLQUFLTixNQUFNTCxPQUFPLEdBQUlLLE1BQU1sSSxNQUFNLEdBQUdrSSxNQUFNTixPQUFPO1FBQ3RELElBQUlhLEtBQUtQLE1BQU1KLE9BQU8sR0FBSUksTUFBTWxJLE1BQU0sR0FBR2tJLE1BQU1QLE9BQU87UUFFdEQzQixRQUFRMEMsU0FBUyxHQUFHLFVBQVVSLE1BQU1YLEtBQUssQ0FBQy9DLENBQUMsR0FBRyxPQUFPMEQsTUFBTVgsS0FBSyxDQUFDN0MsQ0FBQyxHQUFHLE9BQU93RCxNQUFNWCxLQUFLLENBQUM1QyxDQUFDLEdBQUcsT0FBUSxLQUFJMEQsUUFBTyxJQUFLO1FBRXBIckMsUUFBUTJDLFNBQVM7UUFFakIsSUFBSXJMLGVBQWU0SyxNQUFNVixLQUFLLENBQUNvQixJQUFJLEtBQUssVUFBVSxPQUFPVixNQUFNVixLQUFLLENBQUNxQixJQUFJLEtBQUssWUFBWUMsTUFBTUMsT0FBTyxDQUFDYixNQUFNVixLQUFLLENBQUN3QixNQUFNLEdBQUc7WUFDM0hoRCxRQUFRaUQsSUFBSSxDQUFDQyxnQkFDWGhCLE1BQU1WLEtBQUssQ0FBQ3FCLElBQUksRUFDaEJYLE1BQU1WLEtBQUssQ0FBQ3dCLE1BQU0sRUFDbEJkLE1BQU1wRixDQUFDLEVBQ1BvRixNQUFNbkYsQ0FBQyxFQUNQekQsS0FBSzZKLEdBQUcsQ0FBQ1gsS0FBS0YsTUFBTSxLQUNwQmhKLEtBQUs2SixHQUFHLENBQUNWLEtBQUtGLE1BQU0sS0FDcEJqSixLQUFLMEgsRUFBRSxHQUFHLEtBQUtrQixNQUFNaEIsTUFBTTtRQUUvQixPQUFPLElBQUlnQixNQUFNVixLQUFLLENBQUNvQixJQUFJLEtBQUssVUFBVTtZQUN4QyxJQUFJekMsV0FBVzdHLEtBQUswSCxFQUFFLEdBQUcsS0FBS2tCLE1BQU1oQixNQUFNO1lBQzFDLElBQUlrQyxTQUFTOUosS0FBSzZKLEdBQUcsQ0FBQ1gsS0FBS0YsTUFBTTtZQUNqQyxJQUFJZSxTQUFTL0osS0FBSzZKLEdBQUcsQ0FBQ1YsS0FBS0YsTUFBTTtZQUNqQyxJQUFJekosUUFBUW9KLE1BQU1WLEtBQUssQ0FBQzFKLE1BQU0sQ0FBQ2dCLEtBQUssR0FBR29KLE1BQU05RSxNQUFNO1lBQ25ELElBQUlyRSxTQUFTbUosTUFBTVYsS0FBSyxDQUFDMUosTUFBTSxDQUFDaUIsTUFBTSxHQUFHbUosTUFBTTlFLE1BQU07WUFFckQsSUFBSTRGLFNBQVMsSUFBSXhMLFVBQVU7Z0JBQ3pCOEIsS0FBSzZJLEdBQUcsQ0FBQ2hDLFlBQVlpRDtnQkFDckI5SixLQUFLOEksR0FBRyxDQUFDakMsWUFBWWlEO2dCQUNyQixDQUFDOUosS0FBSzhJLEdBQUcsQ0FBQ2pDLFlBQVlrRDtnQkFDdEIvSixLQUFLNkksR0FBRyxDQUFDaEMsWUFBWWtEO2dCQUNyQm5CLE1BQU1wRixDQUFDO2dCQUNQb0YsTUFBTW5GLENBQUM7YUFDUjtZQUVELHFEQUFxRDtZQUNyRGlHLE9BQU9NLFlBQVksQ0FBQyxJQUFJOUwsVUFBVTBLLE1BQU1WLEtBQUssQ0FBQ3dCLE1BQU07WUFFcEQsSUFBSU8sVUFBVXZELFFBQVFoSSxhQUFhLENBQUNRLGFBQWFHLFNBQVMsQ0FBQ3VKLE1BQU1WLEtBQUssQ0FBQzFKLE1BQU0sR0FBRztZQUNoRnlMLFFBQVFDLFlBQVksQ0FBQ1I7WUFFckJoRCxRQUFReUQsV0FBVyxHQUFJLElBQUlwQjtZQUMzQnJDLFFBQVEwQyxTQUFTLEdBQUdhO1lBQ3BCdkQsUUFBUW5JLFFBQVEsQ0FDZHFLLE1BQU1wRixDQUFDLEdBQUloRSxRQUFRLEdBQ25Cb0osTUFBTW5GLENBQUMsR0FBSWhFLFNBQVMsR0FDcEJELE9BQ0FDO1lBRUZpSCxRQUFReUQsV0FBVyxHQUFHO1FBQ3hCLE9BQU8sSUFBSXZCLE1BQU1WLEtBQUssS0FBSyxVQUFVO1lBQ25DeEIsUUFBUUQsT0FBTyxHQUNiQyxRQUFRRCxPQUFPLENBQUNtQyxNQUFNcEYsQ0FBQyxFQUFFb0YsTUFBTW5GLENBQUMsRUFBRXpELEtBQUs2SixHQUFHLENBQUNYLEtBQUtGLE1BQU1KLE1BQU1ILFVBQVUsRUFBRXpJLEtBQUs2SixHQUFHLENBQUNWLEtBQUtGLE1BQU1MLE1BQU1ILFVBQVUsRUFBRXpJLEtBQUswSCxFQUFFLEdBQUcsS0FBS2tCLE1BQU1oQixNQUFNLEVBQUUsR0FBRyxJQUFJNUgsS0FBSzBILEVBQUUsSUFDekpqQixRQUFRQyxTQUFTa0MsTUFBTXBGLENBQUMsRUFBRW9GLE1BQU1uRixDQUFDLEVBQUV6RCxLQUFLNkosR0FBRyxDQUFDWCxLQUFLRixNQUFNSixNQUFNSCxVQUFVLEVBQUV6SSxLQUFLNkosR0FBRyxDQUFDVixLQUFLRixNQUFNTCxNQUFNSCxVQUFVLEVBQUV6SSxLQUFLMEgsRUFBRSxHQUFHLEtBQUtrQixNQUFNaEIsTUFBTSxFQUFFLEdBQUcsSUFBSTVILEtBQUswSCxFQUFFO1FBQzlKLE9BQU8sSUFBSWtCLE1BQU1WLEtBQUssS0FBSyxRQUFRO1lBQ2pDLElBQUlrQyxNQUFNcEssS0FBSzBILEVBQUUsR0FBRyxJQUFJO1lBQ3hCLElBQUkyQyxjQUFjLElBQUl6QixNQUFNOUUsTUFBTTtZQUNsQyxJQUFJd0csY0FBYyxJQUFJMUIsTUFBTTlFLE1BQU07WUFDbEMsSUFBSU4sSUFBSW9GLE1BQU1wRixDQUFDO1lBQ2YsSUFBSUMsSUFBSW1GLE1BQU1uRixDQUFDO1lBQ2YsSUFBSThHLFNBQVM7WUFDYixJQUFJQyxPQUFPeEssS0FBSzBILEVBQUUsR0FBRzZDO1lBRXJCLE1BQU9BLFNBQVU7Z0JBQ2YvRyxJQUFJb0YsTUFBTXBGLENBQUMsR0FBR3hELEtBQUs2SSxHQUFHLENBQUN1QixPQUFPRTtnQkFDOUI3RyxJQUFJbUYsTUFBTW5GLENBQUMsR0FBR3pELEtBQUs4SSxHQUFHLENBQUNzQixPQUFPRTtnQkFDOUI1RCxRQUFRK0QsTUFBTSxDQUFDakgsR0FBR0M7Z0JBQ2xCMkcsT0FBT0k7Z0JBRVBoSCxJQUFJb0YsTUFBTXBGLENBQUMsR0FBR3hELEtBQUs2SSxHQUFHLENBQUN1QixPQUFPQztnQkFDOUI1RyxJQUFJbUYsTUFBTW5GLENBQUMsR0FBR3pELEtBQUs4SSxHQUFHLENBQUNzQixPQUFPQztnQkFDOUIzRCxRQUFRK0QsTUFBTSxDQUFDakgsR0FBR0M7Z0JBQ2xCMkcsT0FBT0k7WUFDVDtRQUNGLE9BQU87WUFDTDlELFFBQVFnRSxNQUFNLENBQUMxSyxLQUFLQyxLQUFLLENBQUMySSxNQUFNcEYsQ0FBQyxHQUFHeEQsS0FBS0MsS0FBSyxDQUFDMkksTUFBTW5GLENBQUM7WUFDdERpRCxRQUFRK0QsTUFBTSxDQUFDekssS0FBS0MsS0FBSyxDQUFDMkksTUFBTUwsT0FBTyxHQUFHdkksS0FBS0MsS0FBSyxDQUFDZ0o7WUFDckR2QyxRQUFRK0QsTUFBTSxDQUFDekssS0FBS0MsS0FBSyxDQUFDaUosS0FBS2xKLEtBQUtDLEtBQUssQ0FBQ2tKO1lBQzFDekMsUUFBUStELE1BQU0sQ0FBQ3pLLEtBQUtDLEtBQUssQ0FBQytJLEtBQUtoSixLQUFLQyxLQUFLLENBQUMySSxNQUFNSixPQUFPO1FBQ3pEO1FBRUE5QixRQUFRaUUsU0FBUztRQUNqQmpFLFFBQVFpRCxJQUFJO1FBRVosT0FBT2YsTUFBTVQsSUFBSSxHQUFHUyxNQUFNUixVQUFVO0lBQ3RDO0lBRUEsU0FBU3dDLFFBQVF4TSxNQUFNLEVBQUV5TSxNQUFNLEVBQUVDLE9BQU8sRUFBRWhKLElBQUksRUFBRUMsSUFBSTtRQUNsRCxJQUFJZ0osa0JBQWtCRixPQUFPNUksS0FBSztRQUNsQyxJQUFJeUUsVUFBVXRJLE9BQU9FLFVBQVUsQ0FBQztRQUNoQyxJQUFJME07UUFDSixJQUFJQztRQUVKLElBQUkvSixPQUFPckMsUUFBUSxTQUFVcUQsT0FBTztZQUNsQyxTQUFTZ0o7Z0JBQ1BGLGlCQUFpQkMsVUFBVTtnQkFFM0J2RSxRQUFReUUsU0FBUyxDQUFDLEdBQUcsR0FBR3JKLEtBQUt0QyxLQUFLLEVBQUVzQyxLQUFLckMsTUFBTTtnQkFDL0NQLGFBQWFVLEtBQUs7Z0JBRWxCbUM7Z0JBQ0FHO1lBQ0Y7WUFFQSxTQUFTa0o7Z0JBQ1AsSUFBSWpPLFlBQVksQ0FBRTJFLENBQUFBLEtBQUt0QyxLQUFLLEtBQUtwQyxXQUFXb0MsS0FBSyxJQUFJc0MsS0FBS3JDLE1BQU0sS0FBS3JDLFdBQVdxQyxNQUFNLEdBQUc7b0JBQ3ZGcUMsS0FBS3RDLEtBQUssR0FBR3BCLE9BQU9vQixLQUFLLEdBQUdwQyxXQUFXb0MsS0FBSztvQkFDNUNzQyxLQUFLckMsTUFBTSxHQUFHckIsT0FBT3FCLE1BQU0sR0FBR3JDLFdBQVdxQyxNQUFNO2dCQUNqRDtnQkFFQSxJQUFJLENBQUNxQyxLQUFLdEMsS0FBSyxJQUFJLENBQUNzQyxLQUFLckMsTUFBTSxFQUFFO29CQUMvQnFMLFFBQVExTTtvQkFDUjBELEtBQUt0QyxLQUFLLEdBQUdwQixPQUFPb0IsS0FBSztvQkFDekJzQyxLQUFLckMsTUFBTSxHQUFHckIsT0FBT3FCLE1BQU07Z0JBQzdCO2dCQUVBaUgsUUFBUXlFLFNBQVMsQ0FBQyxHQUFHLEdBQUdySixLQUFLdEMsS0FBSyxFQUFFc0MsS0FBS3JDLE1BQU07Z0JBRS9Dc0wsa0JBQWtCQSxnQkFBZ0JNLE1BQU0sQ0FBQyxTQUFVekMsS0FBSztvQkFDdEQsT0FBT0QsWUFBWWpDLFNBQVNrQztnQkFDOUI7Z0JBRUEsSUFBSW1DLGdCQUFnQjlGLE1BQU0sRUFBRTtvQkFDMUIrRixpQkFBaUJsTCxJQUFJSSxLQUFLLENBQUNrTDtnQkFDN0IsT0FBTztvQkFDTEY7Z0JBQ0Y7WUFDRjtZQUVBRixpQkFBaUJsTCxJQUFJSSxLQUFLLENBQUNrTDtZQUMzQkgsVUFBVUM7UUFDWjtRQUVBLE9BQU87WUFDTEksV0FBVyxTQUFVVCxNQUFNO2dCQUN6QkUsa0JBQWtCQSxnQkFBZ0JRLE1BQU0sQ0FBQ1Y7Z0JBRXpDLE9BQU8zSjtZQUNUO1lBQ0E5QyxRQUFRQTtZQUNSUyxTQUFTcUM7WUFDVHVCLE9BQU87Z0JBQ0wsSUFBSXVJLGdCQUFnQjtvQkFDbEJsTCxJQUFJSyxNQUFNLENBQUM2SztnQkFDYjtnQkFFQSxJQUFJQyxTQUFTO29CQUNYQTtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVNPLGVBQWVwTixNQUFNLEVBQUVxTixVQUFVO1FBQ3hDLElBQUlDLGNBQWMsQ0FBQ3ROO1FBQ25CLElBQUl1TixjQUFjLENBQUMsQ0FBQ3hILEtBQUtzSCxjQUFjLENBQUMsR0FBRztRQUMzQyxJQUFJRywyQkFBMkI7UUFDL0IsSUFBSUMsZ0NBQWdDMUgsS0FBS3NILFlBQVksMkJBQTJCSztRQUNoRixJQUFJQyxrQkFBa0IxTyxnQkFBZ0IsQ0FBQyxDQUFDOEcsS0FBS3NILGNBQWMsQ0FBQyxHQUFHO1FBQy9ELElBQUl4SyxTQUFTOEssa0JBQWtCL0ssY0FBYztRQUM3QyxJQUFJOEosVUFBVVksY0FBY2hHLHNCQUFzQks7UUFDbEQsSUFBSWlHLGNBQWMsVUFBVy9LLFNBQVUsQ0FBQyxDQUFDN0MsT0FBTzZOLHNCQUFzQixHQUFHO1FBQ3pFLElBQUlDLG1CQUFtQixPQUFPQyxlQUFlLGNBQWNBLFdBQVcsNEJBQTRCQyxPQUFPO1FBQ3pHLElBQUlDO1FBRUosU0FBU0MsVUFBVWhMLE9BQU8sRUFBRVEsSUFBSSxFQUFFQyxJQUFJO1lBQ3BDLElBQUlpQixnQkFBZ0JtQixLQUFLN0MsU0FBUyxpQkFBaUIrQztZQUNuRCxJQUFJcEIsUUFBUWtCLEtBQUs3QyxTQUFTLFNBQVNtRTtZQUNuQyxJQUFJdkMsU0FBU2lCLEtBQUs3QyxTQUFTLFVBQVVtRTtZQUNyQyxJQUFJdEMsZ0JBQWdCZ0IsS0FBSzdDLFNBQVMsaUJBQWlCbUU7WUFDbkQsSUFBSXJDLFFBQVFlLEtBQUs3QyxTQUFTLFNBQVNtRTtZQUNuQyxJQUFJcEMsVUFBVWMsS0FBSzdDLFNBQVMsV0FBV21FO1lBQ3ZDLElBQUluQyxRQUFRYSxLQUFLN0MsU0FBUyxTQUFTbUU7WUFDbkMsSUFBSTdCLFNBQVNPLEtBQUs3QyxTQUFTLFVBQVV1RDtZQUNyQyxJQUFJdEIsUUFBUVksS0FBSzdDLFNBQVMsU0FBU21FO1lBQ25DLElBQUkvQixTQUFTUyxLQUFLN0MsU0FBUztZQUMzQixJQUFJd0MsU0FBU0ssS0FBSzdDLFNBQVM7WUFDM0IsSUFBSW9ILE9BQU8sQ0FBQyxDQUFDdkUsS0FBSzdDLFNBQVM7WUFDM0IsSUFBSWlFLFNBQVNELFVBQVVoRTtZQUV2QixJQUFJaUwsT0FBT3ZKO1lBQ1gsSUFBSTZILFNBQVMsRUFBRTtZQUVmLElBQUkyQixTQUFTcE8sT0FBT29CLEtBQUssR0FBRytGLE9BQU8vQixDQUFDO1lBQ3BDLElBQUlpSixTQUFTck8sT0FBT3FCLE1BQU0sR0FBRzhGLE9BQU85QixDQUFDO1lBRXJDLE1BQU84SSxPQUFRO2dCQUNiMUIsT0FBTzZCLElBQUksQ0FDVG5GLGNBQWM7b0JBQ1ovRCxHQUFHZ0o7b0JBQ0gvSSxHQUFHZ0o7b0JBQ0h4SixPQUFPQTtvQkFDUEMsUUFBUUE7b0JBQ1JDLGVBQWVBO29CQUNmOEUsT0FBT3JFLE1BQU0sQ0FBQzJJLE9BQU8zSSxPQUFPcUIsTUFBTSxDQUFDO29CQUNuQ2lELE9BQU94RSxNQUFNLENBQUNhLFVBQVUsR0FBR2IsT0FBT3VCLE1BQU0sRUFBRTtvQkFDMUMxQixPQUFPQTtvQkFDUEgsT0FBT0E7b0JBQ1BDLFNBQVNBO29CQUNUQyxPQUFPQTtvQkFDUFEsUUFBUUE7b0JBQ1I0RSxNQUFNQTtnQkFDUjtZQUVKO1lBRUEsa0RBQWtEO1lBQ2xELFlBQVk7WUFDWixJQUFJMkQsY0FBYztnQkFDaEIsT0FBT0EsYUFBYWYsU0FBUyxDQUFDVDtZQUNoQztZQUVBd0IsZUFBZXpCLFFBQVF4TSxRQUFReU0sUUFBUUMsU0FBU2hKLE1BQU9DO1lBRXZELE9BQU9zSyxhQUFheE4sT0FBTztRQUM3QjtRQUVBLFNBQVMrQyxLQUFLTixPQUFPO1lBQ25CLElBQUl1QywwQkFBMEJnSSxpQ0FBaUMxSCxLQUFLN0MsU0FBUywyQkFBMkJ3SztZQUN4RyxJQUFJbkksU0FBU1EsS0FBSzdDLFNBQVMsVUFBVW1FO1lBRXJDLElBQUk1QiwyQkFBMkJxSSxrQkFBa0I7Z0JBQy9DLE9BQU9yTixRQUFRLFNBQVVxRCxPQUFPO29CQUM5QkE7Z0JBQ0Y7WUFDRjtZQUVBLElBQUl3SixlQUFlVyxjQUFjO2dCQUMvQixpREFBaUQ7Z0JBQ2pEak8sU0FBU2lPLGFBQWFqTyxNQUFNO1lBQzlCLE9BQU8sSUFBSXNOLGVBQWUsQ0FBQ3ROLFFBQVE7Z0JBQ2pDLHFDQUFxQztnQkFDckNBLFNBQVM4SCxVQUFVdkM7Z0JBQ25CZ0MsU0FBU2dILElBQUksQ0FBQ0MsV0FBVyxDQUFDeE87WUFDNUI7WUFFQSxJQUFJdU4sZUFBZSxDQUFDSyxhQUFhO2dCQUMvQixnREFBZ0Q7Z0JBQ2hEbEIsUUFBUTFNO1lBQ1Y7WUFFQSxJQUFJMEQsT0FBTztnQkFDVHRDLE9BQU9wQixPQUFPb0IsS0FBSztnQkFDbkJDLFFBQVFyQixPQUFPcUIsTUFBTTtZQUN2QjtZQUVBLElBQUl3QixVQUFVLENBQUMrSyxhQUFhO2dCQUMxQi9LLE9BQU9RLElBQUksQ0FBQ3JEO1lBQ2Q7WUFFQTROLGNBQWM7WUFFZCxJQUFJL0ssUUFBUTtnQkFDVjdDLE9BQU82TixzQkFBc0IsR0FBRztZQUNsQztZQUVBLFNBQVNZO2dCQUNQLElBQUk1TCxRQUFRO29CQUNWLG1FQUFtRTtvQkFDbkUsSUFBSTZMLE1BQU07d0JBQ1I3Ryx1QkFBdUI7NEJBQ3JCLElBQUksQ0FBQ3lGLGFBQWE7Z0NBQ2hCLE9BQU90TixPQUFPNkgscUJBQXFCOzRCQUNyQzt3QkFDRjtvQkFDRjtvQkFFQTZFLFFBQVFnQztvQkFFUjdMLE9BQU9PLFdBQVcsQ0FBQzt3QkFDakJ1TCxRQUFROzRCQUNOdk4sT0FBT3NOLElBQUl0TixLQUFLOzRCQUNoQkMsUUFBUXFOLElBQUlyTixNQUFNO3dCQUNwQjtvQkFDRjtvQkFDQTtnQkFDRjtnQkFFQSxpREFBaUQ7Z0JBQ2pELHFDQUFxQztnQkFDckNxQyxLQUFLdEMsS0FBSyxHQUFHc0MsS0FBS3JDLE1BQU0sR0FBRztZQUM3QjtZQUVBLFNBQVNzQztnQkFDUHNLLGVBQWU7Z0JBRWYsSUFBSVYsYUFBYTtvQkFDZkMsMkJBQTJCO29CQUMzQjFPLE9BQU9vRixtQkFBbUIsQ0FBQyxVQUFVdUs7Z0JBQ3ZDO2dCQUVBLElBQUluQixlQUFldE4sUUFBUTtvQkFDekIsSUFBSXVILFNBQVNnSCxJQUFJLENBQUNLLFFBQVEsQ0FBQzVPLFNBQVM7d0JBQ2xDdUgsU0FBU2dILElBQUksQ0FBQ00sV0FBVyxDQUFDN087b0JBQzVCO29CQUNBQSxTQUFTO29CQUNUNE4sY0FBYztnQkFDaEI7WUFDRjtZQUVBLElBQUlMLGVBQWUsQ0FBQ0MsMEJBQTBCO2dCQUM1Q0EsMkJBQTJCO2dCQUMzQjFPLE9BQU9xRixnQkFBZ0IsQ0FBQyxVQUFVc0ssVUFBVTtZQUM5QztZQUVBLElBQUk1TCxRQUFRO2dCQUNWLE9BQU9BLE9BQU9XLElBQUksQ0FBQ04sU0FBU1EsTUFBTUM7WUFDcEM7WUFFQSxPQUFPdUssVUFBVWhMLFNBQVNRLE1BQU1DO1FBQ2xDO1FBRUFILEtBQUthLEtBQUssR0FBRztZQUNYLElBQUl4QixRQUFRO2dCQUNWQSxPQUFPd0IsS0FBSztZQUNkO1lBRUEsSUFBSTRKLGNBQWM7Z0JBQ2hCQSxhQUFhNUosS0FBSztZQUNwQjtRQUNGO1FBRUEsT0FBT2I7SUFDVDtJQUVBLGtFQUFrRTtJQUNsRSxJQUFJc0w7SUFDSixTQUFTQztRQUNQLElBQUksQ0FBQ0QsYUFBYTtZQUNoQkEsY0FBYzFCLGVBQWUsTUFBTTtnQkFBRTRCLFdBQVc7Z0JBQU1MLFFBQVE7WUFBSztRQUNyRTtRQUNBLE9BQU9HO0lBQ1Q7SUFFQSxTQUFTdEQsZ0JBQWdCeUQsVUFBVSxFQUFFQyxVQUFVLEVBQUU5SixDQUFDLEVBQUVDLENBQUMsRUFBRXFHLE1BQU0sRUFBRUMsTUFBTSxFQUFFbEQsUUFBUTtRQUM3RSxJQUFJMEcsU0FBUyxJQUFJdFAsT0FBT29QO1FBRXhCLElBQUlHLEtBQUssSUFBSXZQO1FBQ2J1UCxHQUFHQyxPQUFPLENBQUNGLFFBQVEsSUFBSXJQLFVBQVVvUDtRQUVqQyxJQUFJSSxLQUFLLElBQUl6UDtRQUNiLDJFQUEyRTtRQUMzRXlQLEdBQUdELE9BQU8sQ0FBQ0QsSUFBSSxJQUFJdFAsVUFBVTtZQUMzQjhCLEtBQUs2SSxHQUFHLENBQUNoQyxZQUFZaUQ7WUFDckI5SixLQUFLOEksR0FBRyxDQUFDakMsWUFBWWlEO1lBQ3JCLENBQUM5SixLQUFLOEksR0FBRyxDQUFDakMsWUFBWWtEO1lBQ3RCL0osS0FBSzZJLEdBQUcsQ0FBQ2hDLFlBQVlrRDtZQUNyQnZHO1lBQ0FDO1NBQ0Q7UUFFRCxPQUFPaUs7SUFDVDtJQUVBLFNBQVNDLGNBQWNDLFFBQVE7UUFDN0IsSUFBSSxDQUFDNVAsYUFBYTtZQUNoQixNQUFNLElBQUk2UCxNQUFNO1FBQ2xCO1FBRUEsSUFBSXRFLE1BQU1HO1FBRVYsSUFBSSxPQUFPa0UsYUFBYSxVQUFVO1lBQ2hDckUsT0FBT3FFO1FBQ1QsT0FBTztZQUNMckUsT0FBT3FFLFNBQVNyRSxJQUFJO1lBQ3BCRyxTQUFTa0UsU0FBU2xFLE1BQU07UUFDMUI7UUFFQSxJQUFJNkQsU0FBUyxJQUFJdFAsT0FBT3NMO1FBQ3hCLElBQUl1RSxhQUFhbkksU0FBU1EsYUFBYSxDQUFDO1FBQ3hDLElBQUk0SCxVQUFVRCxXQUFXeFAsVUFBVSxDQUFDO1FBRXBDLElBQUksQ0FBQ29MLFFBQVE7WUFDWCwrREFBK0Q7WUFDL0QsSUFBSXNFLFVBQVU7WUFDZCxJQUFJQyxPQUFPRDtZQUNYLElBQUlFLE9BQU9GO1lBQ1gsSUFBSUcsT0FBTztZQUNYLElBQUlDLE9BQU87WUFDWCxJQUFJNU8sT0FBT0M7WUFFWCx3REFBd0Q7WUFDeEQsK0NBQStDO1lBQy9DLElBQUssSUFBSStELElBQUksR0FBR0EsSUFBSXdLLFNBQVN4SyxLQUFLLEVBQUc7Z0JBQ25DLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJdUssU0FBU3ZLLEtBQUssRUFBRztvQkFDbkMsSUFBSXNLLFFBQVFNLGFBQWEsQ0FBQ2QsUUFBUS9KLEdBQUdDLEdBQUcsWUFBWTt3QkFDbER3SyxPQUFPak8sS0FBS3dFLEdBQUcsQ0FBQ3lKLE1BQU16Szt3QkFDdEIwSyxPQUFPbE8sS0FBS3dFLEdBQUcsQ0FBQzBKLE1BQU16Szt3QkFDdEIwSyxPQUFPbk8sS0FBS3lFLEdBQUcsQ0FBQzBKLE1BQU0zSzt3QkFDdEI0SyxPQUFPcE8sS0FBS3lFLEdBQUcsQ0FBQzJKLE1BQU0zSztvQkFDeEI7Z0JBQ0Y7WUFDRjtZQUVBakUsUUFBUTJPLE9BQU9GO1lBQ2Z4TyxTQUFTMk8sT0FBT0Y7WUFFaEIsSUFBSUksaUJBQWlCO1lBQ3JCLElBQUlsSCxRQUFRcEgsS0FBS3dFLEdBQUcsQ0FBQzhKLGlCQUFlOU8sT0FBTzhPLGlCQUFlN087WUFFMURpSyxTQUFTO2dCQUNQdEM7Z0JBQU87Z0JBQUc7Z0JBQUdBO2dCQUNiLENBQUNwSCxLQUFLdU8sS0FBSyxDQUFDLFFBQU8sSUFBS04sUUFBUTdHO2dCQUNoQyxDQUFDcEgsS0FBS3VPLEtBQUssQ0FBQyxTQUFRLElBQUtMLFFBQVE5RzthQUNsQztRQUNIO1FBRUEsT0FBTztZQUNMa0MsTUFBTTtZQUNOQyxNQUFNQTtZQUNORyxRQUFRQTtRQUNWO0lBQ0Y7SUFFQSxTQUFTOEUsY0FBY0MsUUFBUTtRQUM3QixJQUFJQyxNQUNBNUssU0FBUyxHQUNUbUUsUUFBUSxXQUNSLHdGQUF3RjtRQUN4RjBHLGFBQWE7UUFFakIsSUFBSSxPQUFPRixhQUFhLFVBQVU7WUFDaENDLE9BQU9EO1FBQ1QsT0FBTztZQUNMQyxPQUFPRCxTQUFTQyxJQUFJO1lBQ3BCNUssU0FBUyxZQUFZMkssV0FBV0EsU0FBUzNLLE1BQU0sR0FBR0E7WUFDbEQ2SyxhQUFhLGdCQUFnQkYsV0FBV0EsU0FBU0UsVUFBVSxHQUFHQTtZQUM5RDFHLFFBQVEsV0FBV3dHLFdBQVdBLFNBQVN4RyxLQUFLLEdBQUdBO1FBQ2pEO1FBRUEsb0NBQW9DO1FBQ3BDLHlEQUF5RDtRQUN6RCxJQUFJMkcsV0FBVyxLQUFLOUs7UUFDcEIsSUFBSStLLE9BQU8sS0FBS0QsV0FBVyxRQUFRRDtRQUVuQyxJQUFJdlEsU0FBUyxJQUFJWCxnQkFBZ0JtUixVQUFVQTtRQUMzQyxJQUFJdlEsTUFBTUQsT0FBT0UsVUFBVSxDQUFDO1FBRTVCRCxJQUFJd1EsSUFBSSxHQUFHQTtRQUNYLElBQUkvTSxPQUFPekQsSUFBSXlRLFdBQVcsQ0FBQ0o7UUFDM0IsSUFBSWxQLFFBQVFRLEtBQUsrTyxJQUFJLENBQUNqTixLQUFLa04sc0JBQXNCLEdBQUdsTixLQUFLbU4scUJBQXFCO1FBQzlFLElBQUl4UCxTQUFTTyxLQUFLK08sSUFBSSxDQUFDak4sS0FBS29OLHVCQUF1QixHQUFHcE4sS0FBS3FOLHdCQUF3QjtRQUVuRixJQUFJQyxVQUFVO1FBQ2QsSUFBSTVMLElBQUkxQixLQUFLbU4scUJBQXFCLEdBQUdHO1FBQ3JDLElBQUkzTCxJQUFJM0IsS0FBS29OLHVCQUF1QixHQUFHRTtRQUN2QzVQLFNBQVM0UCxVQUFVQTtRQUNuQjNQLFVBQVUyUCxVQUFVQTtRQUVwQmhSLFNBQVMsSUFBSVgsZ0JBQWdCK0IsT0FBT0M7UUFDcENwQixNQUFNRCxPQUFPRSxVQUFVLENBQUM7UUFDeEJELElBQUl3USxJQUFJLEdBQUdBO1FBQ1h4USxJQUFJK0ssU0FBUyxHQUFHbkI7UUFFaEI1SixJQUFJZ1IsUUFBUSxDQUFDWCxNQUFNbEwsR0FBR0M7UUFFdEIsSUFBSTJELFFBQVEsSUFBSXREO1FBRWhCLE9BQU87WUFDTHdGLE1BQU07WUFDTix3REFBd0Q7WUFDeEQ5SyxRQUFRSixPQUFPSyxxQkFBcUI7WUFDcENpTCxRQUFRO2dCQUFDdEM7Z0JBQU87Z0JBQUc7Z0JBQUdBO2dCQUFPLENBQUM1SCxRQUFRNEgsUUFBUTtnQkFBRyxDQUFDM0gsU0FBUzJILFFBQVE7YUFBRTtRQUN2RTtJQUNGO0lBRUFwSyxPQUFPZ0MsT0FBTyxHQUFHO1FBQ2YsT0FBT21PLGlCQUFpQm1DLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0lBQ3RDO0lBQ0F2UyxPQUFPZ0MsT0FBTyxDQUFDeUQsS0FBSyxHQUFHO1FBQ3JCMEssaUJBQWlCMUssS0FBSztJQUN4QjtJQUNBekYsT0FBT2dDLE9BQU8sQ0FBQ3dRLE1BQU0sR0FBR2hFO0lBQ3hCeE8sT0FBT2dDLE9BQU8sQ0FBQzJPLGFBQWEsR0FBR0E7SUFDL0IzUSxPQUFPZ0MsT0FBTyxDQUFDd1AsYUFBYSxHQUFHQTtBQUNqQyxHQUFFO0lBQ0EsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBRUQsSUFBSSxPQUFPa0IsU0FBUyxhQUFhO1FBQy9CLE9BQU9BO0lBQ1Q7SUFFQSxPQUFPLElBQUksSUFBSSxDQUFDO0FBQ2xCLEtBQU0xUyxRQUFRO0FBRWQscUJBQXFCO0FBRXJCLGlFQUFlQSxPQUFPZ0MsT0FBTyxFQUFDO0FBQ3ZCLElBQUl3USxTQUFTeFMsT0FBT2dDLE9BQU8sQ0FBQ3dRLE1BQU0sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VuaWdtYS1iaW5nby8uL25vZGVfbW9kdWxlcy9jYW52YXMtY29uZmV0dGkvZGlzdC9jb25mZXR0aS5tb2R1bGUubWpzP2YxZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FudmFzLWNvbmZldHRpIHYxLjkuNCBidWlsdCBvbiAyMDI1LTEwLTI1VDA1OjE0OjU2LjY0MFpcbnZhciBtb2R1bGUgPSB7fTtcblxuLy8gc291cmNlIGNvbnRlbnRcbi8qIGdsb2JhbHMgTWFwICovXG5cbihmdW5jdGlvbiBtYWluKGdsb2JhbCwgbW9kdWxlLCBpc1dvcmtlciwgd29ya2VyU2l6ZSkge1xuICB2YXIgY2FuVXNlV29ya2VyID0gISEoXG4gICAgZ2xvYmFsLldvcmtlciAmJlxuICAgIGdsb2JhbC5CbG9iICYmXG4gICAgZ2xvYmFsLlByb21pc2UgJiZcbiAgICBnbG9iYWwuT2Zmc2NyZWVuQ2FudmFzICYmXG4gICAgZ2xvYmFsLk9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmJlxuICAgIGdsb2JhbC5IVE1MQ2FudmFzRWxlbWVudCAmJlxuICAgIGdsb2JhbC5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4gJiZcbiAgICBnbG9iYWwuVVJMICYmXG4gICAgZ2xvYmFsLlVSTC5jcmVhdGVPYmplY3RVUkwpO1xuXG4gIHZhciBjYW5Vc2VQYXRocyA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIERPTU1hdHJpeCA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIGNhbkRyYXdCaXRtYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIHRoaXMgbW9zdGx5IHN1cHBvcnRzIHNzclxuICAgIGlmICghZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgIHZhciBiaXRtYXAgPSBjYW52YXMudHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgICBjdHguY3JlYXRlUGF0dGVybihiaXRtYXAsICduby1yZXBlYXQnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgLy8gY3JlYXRlIGEgcHJvbWlzZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSwganVzdFxuICAvLyBjYWxsIHRoZSBmdW5jdGlvbiBkaXJlY3RseVxuICBmdW5jdGlvbiBwcm9taXNlKGZ1bmMpIHtcbiAgICB2YXIgTW9kdWxlUHJvbWlzZSA9IG1vZHVsZS5leHBvcnRzLlByb21pc2U7XG4gICAgdmFyIFByb20gPSBNb2R1bGVQcm9taXNlICE9PSB2b2lkIDAgPyBNb2R1bGVQcm9taXNlIDogZ2xvYmFsLlByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIFByb20gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbShmdW5jKTtcbiAgICB9XG5cbiAgICBmdW5jKG5vb3AsIG5vb3ApO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYml0bWFwTWFwcGVyID0gKGZ1bmN0aW9uIChza2lwVHJhbnNmb3JtLCBtYXApIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NhdGRhZC9jYW52YXMtY29uZmV0dGkvaXNzdWVzLzIwOVxuICAgIC8vIGNyZWF0aW5nIGNhbnZhc2VzIGlzIGFjdHVhbGx5IHByZXR0eSBleHBlbnNpdmUsIHNvIHdlIHNob3VsZCBjcmVhdGUgYVxuICAgIC8vIDE6MSBtYXAgZm9yIGJpdG1hcDpjYW52YXMsIHNvIHRoYXQgd2UgY2FuIGFuaW1hdGUgdGhlIGNvbmZldHRpIGluXG4gICAgLy8gYSBwZXJmb3JtYW50IG1hbm5lciwgYnV0IGFsc28gbm90IHN0b3JlIHRoZW0gZm9yZXZlciBzbyB0aGF0IHdlIGRvbid0XG4gICAgLy8gaGF2ZSBhIG1lbW9yeSBsZWFrXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oYml0bWFwKSB7XG4gICAgICAgIGlmIChza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgICAgcmV0dXJuIGJpdG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXAuaGFzKGJpdG1hcCkpIHtcbiAgICAgICAgICByZXR1cm4gbWFwLmdldChiaXRtYXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KTtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG5cbiAgICAgICAgbWFwLnNldChiaXRtYXAsIGNhbnZhcyk7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgIH0sXG4gICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICBtYXAuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KShjYW5EcmF3Qml0bWFwLCBuZXcgTWFwKCkpO1xuXG4gIHZhciByYWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBUSU1FID0gTWF0aC5mbG9vcigxMDAwIC8gNjApO1xuICAgIHZhciBmcmFtZSwgY2FuY2VsO1xuICAgIHZhciBmcmFtZXMgPSB7fTtcbiAgICB2YXIgbGFzdEZyYW1lVGltZSA9IDA7XG5cbiAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZyYW1lID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBpZCA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgZnJhbWVzW2lkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBvbkZyYW1lKHRpbWUpIHtcbiAgICAgICAgICBpZiAobGFzdEZyYW1lVGltZSA9PT0gdGltZSB8fCBsYXN0RnJhbWVUaW1lICsgVElNRSAtIDEgPCB0aW1lKSB7XG4gICAgICAgICAgICBsYXN0RnJhbWVUaW1lID0gdGltZTtcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFtZXNbaWRdO1xuXG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFtZXNbaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfTtcbiAgICAgIGNhbmNlbCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoZnJhbWVzW2lkXSkge1xuICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lc1tpZF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChjYiwgVElNRSk7XG4gICAgICB9O1xuICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBmcmFtZTogZnJhbWUsIGNhbmNlbDogY2FuY2VsIH07XG4gIH0oKSk7XG5cbiAgdmFyIGdldFdvcmtlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdvcmtlcjtcbiAgICB2YXIgcHJvbTtcbiAgICB2YXIgcmVzb2x2ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlY29yYXRlKHdvcmtlcikge1xuICAgICAgZnVuY3Rpb24gZXhlY3V0ZShvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBvcHRpb25zOiBvcHRpb25zIHx8IHt9LCBjYWxsYmFjazogY2FsbGJhY2sgfSk7XG4gICAgICB9XG4gICAgICB3b3JrZXIuaW5pdCA9IGZ1bmN0aW9uIGluaXRXb3JrZXIoY2FudmFzKSB7XG4gICAgICAgIHZhciBvZmZzY3JlZW4gPSBjYW52YXMudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4oKTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgY2FudmFzOiBvZmZzY3JlZW4gfSwgW29mZnNjcmVlbl0pO1xuICAgICAgfTtcblxuICAgICAgd29ya2VyLmZpcmUgPSBmdW5jdGlvbiBmaXJlV29ya2VyKG9wdGlvbnMsIHNpemUsIGRvbmUpIHtcbiAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICBleGVjdXRlKG9wdGlvbnMsIG51bGwpO1xuICAgICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbiAgICAgICAgcHJvbSA9IHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBmdW5jdGlvbiB3b3JrZXJEb25lKG1zZykge1xuICAgICAgICAgICAgaWYgKG1zZy5kYXRhLmNhbGxiYWNrICE9PSBpZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSByZXNvbHZlc1tpZF07XG4gICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHdvcmtlckRvbmUpO1xuXG4gICAgICAgICAgICBwcm9tID0gbnVsbDtcblxuICAgICAgICAgICAgYml0bWFwTWFwcGVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHdvcmtlckRvbmUpO1xuICAgICAgICAgIGV4ZWN1dGUob3B0aW9ucywgaWQpO1xuXG4gICAgICAgICAgcmVzb2x2ZXNbaWRdID0gd29ya2VyRG9uZS5iaW5kKG51bGwsIHsgZGF0YTogeyBjYWxsYmFjazogaWQgfX0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgIH07XG5cbiAgICAgIHdvcmtlci5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0V29ya2VyKCkge1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyByZXNldDogdHJ1ZSB9KTtcblxuICAgICAgICBmb3IgKHZhciBpZCBpbiByZXNvbHZlcykge1xuICAgICAgICAgIHJlc29sdmVzW2lkXSgpO1xuICAgICAgICAgIGRlbGV0ZSByZXNvbHZlc1tpZF07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1dvcmtlciAmJiBjYW5Vc2VXb3JrZXIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBbXG4gICAgICAgICAgJ3ZhciBDT05GRVRUSSwgU0laRSA9IHt9LCBtb2R1bGUgPSB7fTsnLFxuICAgICAgICAgICcoJyArIG1haW4udG9TdHJpbmcoKSArICcpKHRoaXMsIG1vZHVsZSwgdHJ1ZSwgU0laRSk7JyxcbiAgICAgICAgICAnb25tZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7JyxcbiAgICAgICAgICAnICBpZiAobXNnLmRhdGEub3B0aW9ucykgeycsXG4gICAgICAgICAgJyAgICBDT05GRVRUSShtc2cuZGF0YS5vcHRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHsnLFxuICAgICAgICAgICcgICAgICBpZiAobXNnLmRhdGEuY2FsbGJhY2spIHsnLFxuICAgICAgICAgICcgICAgICAgIHBvc3RNZXNzYWdlKHsgY2FsbGJhY2s6IG1zZy5kYXRhLmNhbGxiYWNrIH0pOycsXG4gICAgICAgICAgJyAgICAgIH0nLFxuICAgICAgICAgICcgICAgfSk7JyxcbiAgICAgICAgICAnICB9IGVsc2UgaWYgKG1zZy5kYXRhLnJlc2V0KSB7JyxcbiAgICAgICAgICAnICAgIENPTkZFVFRJICYmIENPTkZFVFRJLnJlc2V0KCk7JyxcbiAgICAgICAgICAnICB9IGVsc2UgaWYgKG1zZy5kYXRhLnJlc2l6ZSkgeycsXG4gICAgICAgICAgJyAgICBTSVpFLndpZHRoID0gbXNnLmRhdGEucmVzaXplLndpZHRoOycsXG4gICAgICAgICAgJyAgICBTSVpFLmhlaWdodCA9IG1zZy5kYXRhLnJlc2l6ZS5oZWlnaHQ7JyxcbiAgICAgICAgICAnICB9IGVsc2UgaWYgKG1zZy5kYXRhLmNhbnZhcykgeycsXG4gICAgICAgICAgJyAgICBTSVpFLndpZHRoID0gbXNnLmRhdGEuY2FudmFzLndpZHRoOycsXG4gICAgICAgICAgJyAgICBTSVpFLmhlaWdodCA9IG1zZy5kYXRhLmNhbnZhcy5oZWlnaHQ7JyxcbiAgICAgICAgICAnICAgIENPTkZFVFRJID0gbW9kdWxlLmV4cG9ydHMuY3JlYXRlKG1zZy5kYXRhLmNhbnZhcyk7JyxcbiAgICAgICAgICAnICB9JyxcbiAgICAgICAgICAnfScsXG4gICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd29ya2VyID0gbmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtjb2RlXSkpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgPyBjb25zb2xlLndhcm4oJ/CfjoogQ291bGQgbm90IGxvYWQgd29ya2VyJywgZSkgOiBudWxsO1xuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvcmF0ZSh3b3JrZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHBhcnRpY2xlQ291bnQ6IDUwLFxuICAgIGFuZ2xlOiA5MCxcbiAgICBzcHJlYWQ6IDQ1LFxuICAgIHN0YXJ0VmVsb2NpdHk6IDQ1LFxuICAgIGRlY2F5OiAwLjksXG4gICAgZ3Jhdml0eTogMSxcbiAgICBkcmlmdDogMCxcbiAgICB0aWNrczogMjAwLFxuICAgIHg6IDAuNSxcbiAgICB5OiAwLjUsXG4gICAgc2hhcGVzOiBbJ3NxdWFyZScsICdjaXJjbGUnXSxcbiAgICB6SW5kZXg6IDEwMCxcbiAgICBjb2xvcnM6IFtcbiAgICAgICcjMjZjY2ZmJyxcbiAgICAgICcjYTI1YWZkJyxcbiAgICAgICcjZmY1ZTdlJyxcbiAgICAgICcjODhmZjVhJyxcbiAgICAgICcjZmNmZjQyJyxcbiAgICAgICcjZmZhNjJkJyxcbiAgICAgICcjZmYzNmZmJ1xuICAgIF0sXG4gICAgLy8gcHJvYmFibHkgc2hvdWxkIGJlIHRydWUsIGJ1dCBiYWNrLWNvbXBhdFxuICAgIGRpc2FibGVGb3JSZWR1Y2VkTW90aW9uOiBmYWxzZSxcbiAgICBzY2FsYXI6IDFcbiAgfTtcblxuICBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybSA/IHRyYW5zZm9ybSh2YWwpIDogdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPayh2YWwpIHtcbiAgICByZXR1cm4gISh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvcChvcHRpb25zLCBuYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gY29udmVydChcbiAgICAgIG9wdGlvbnMgJiYgaXNPayhvcHRpb25zW25hbWVdKSA/IG9wdGlvbnNbbmFtZV0gOiBkZWZhdWx0c1tuYW1lXSxcbiAgICAgIHRyYW5zZm9ybVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmx5UG9zaXRpdmVJbnQobnVtYmVyKXtcbiAgICByZXR1cm4gbnVtYmVyIDwgMCA/IDAgOiBNYXRoLmZsb29yKG51bWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb21JbnQobWluLCBtYXgpIHtcbiAgICAvLyBbbWluLCBtYXgpXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvRGVjaW1hbChzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxNik7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xvcnNUb1JnYihjb2xvcnMpIHtcbiAgICByZXR1cm4gY29sb3JzLm1hcChoZXhUb1JnYik7XG4gIH1cblxuICBmdW5jdGlvbiBoZXhUb1JnYihzdHIpIHtcbiAgICB2YXIgdmFsID0gU3RyaW5nKHN0cikucmVwbGFjZSgvW14wLTlhLWZdL2dpLCAnJyk7XG5cbiAgICBpZiAodmFsLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgdmFsID0gdmFsWzBdK3ZhbFswXSt2YWxbMV0rdmFsWzFdK3ZhbFsyXSt2YWxbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHRvRGVjaW1hbCh2YWwuc3Vic3RyaW5nKDAsMikpLFxuICAgICAgZzogdG9EZWNpbWFsKHZhbC5zdWJzdHJpbmcoMiw0KSksXG4gICAgICBiOiB0b0RlY2ltYWwodmFsLnN1YnN0cmluZyg0LDYpKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcmlnaW4ob3B0aW9ucykge1xuICAgIHZhciBvcmlnaW4gPSBwcm9wKG9wdGlvbnMsICdvcmlnaW4nLCBPYmplY3QpO1xuICAgIG9yaWdpbi54ID0gcHJvcChvcmlnaW4sICd4JywgTnVtYmVyKTtcbiAgICBvcmlnaW4ueSA9IHByb3Aob3JpZ2luLCAneScsIE51bWJlcik7XG5cbiAgICByZXR1cm4gb3JpZ2luO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FudmFzV2luZG93U2l6ZShjYW52YXMpIHtcbiAgICBjYW52YXMud2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYW52YXNSZWN0U2l6ZShjYW52YXMpIHtcbiAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjYW52YXMud2lkdGggPSByZWN0LndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENhbnZhcyh6SW5kZXgpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgZnVuY3Rpb24gZWxsaXBzZShjb250ZXh0LCB4LCB5LCByYWRpdXNYLCByYWRpdXNZLCByb3RhdGlvbiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgY29udGV4dC5zY2FsZShyYWRpdXNYLCByYWRpdXNZKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCAxLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb21QaHlzaWNzKG9wdHMpIHtcbiAgICB2YXIgcmFkQW5nbGUgPSBvcHRzLmFuZ2xlICogKE1hdGguUEkgLyAxODApO1xuICAgIHZhciByYWRTcHJlYWQgPSBvcHRzLnNwcmVhZCAqIChNYXRoLlBJIC8gMTgwKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBvcHRzLngsXG4gICAgICB5OiBvcHRzLnksXG4gICAgICB3b2JibGU6IE1hdGgucmFuZG9tKCkgKiAxMCxcbiAgICAgIHdvYmJsZVNwZWVkOiBNYXRoLm1pbigwLjExLCBNYXRoLnJhbmRvbSgpICogMC4xICsgMC4wNSksXG4gICAgICB2ZWxvY2l0eTogKG9wdHMuc3RhcnRWZWxvY2l0eSAqIDAuNSkgKyAoTWF0aC5yYW5kb20oKSAqIG9wdHMuc3RhcnRWZWxvY2l0eSksXG4gICAgICBhbmdsZTJEOiAtcmFkQW5nbGUgKyAoKDAuNSAqIHJhZFNwcmVhZCkgLSAoTWF0aC5yYW5kb20oKSAqIHJhZFNwcmVhZCkpLFxuICAgICAgdGlsdEFuZ2xlOiAoTWF0aC5yYW5kb20oKSAqICgwLjc1IC0gMC4yNSkgKyAwLjI1KSAqIE1hdGguUEksXG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIHNoYXBlOiBvcHRzLnNoYXBlLFxuICAgICAgdGljazogMCxcbiAgICAgIHRvdGFsVGlja3M6IG9wdHMudGlja3MsXG4gICAgICBkZWNheTogb3B0cy5kZWNheSxcbiAgICAgIGRyaWZ0OiBvcHRzLmRyaWZ0LFxuICAgICAgcmFuZG9tOiBNYXRoLnJhbmRvbSgpICsgMixcbiAgICAgIHRpbHRTaW46IDAsXG4gICAgICB0aWx0Q29zOiAwLFxuICAgICAgd29iYmxlWDogMCxcbiAgICAgIHdvYmJsZVk6IDAsXG4gICAgICBncmF2aXR5OiBvcHRzLmdyYXZpdHkgKiAzLFxuICAgICAgb3ZhbFNjYWxhcjogMC42LFxuICAgICAgc2NhbGFyOiBvcHRzLnNjYWxhcixcbiAgICAgIGZsYXQ6IG9wdHMuZmxhdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGZXR0aShjb250ZXh0LCBmZXR0aSkge1xuICAgIGZldHRpLnggKz0gTWF0aC5jb3MoZmV0dGkuYW5nbGUyRCkgKiBmZXR0aS52ZWxvY2l0eSArIGZldHRpLmRyaWZ0O1xuICAgIGZldHRpLnkgKz0gTWF0aC5zaW4oZmV0dGkuYW5nbGUyRCkgKiBmZXR0aS52ZWxvY2l0eSArIGZldHRpLmdyYXZpdHk7XG4gICAgZmV0dGkudmVsb2NpdHkgKj0gZmV0dGkuZGVjYXk7XG5cbiAgICBpZiAoZmV0dGkuZmxhdCkge1xuICAgICAgZmV0dGkud29iYmxlID0gMDtcbiAgICAgIGZldHRpLndvYmJsZVggPSBmZXR0aS54ICsgKDEwICogZmV0dGkuc2NhbGFyKTtcbiAgICAgIGZldHRpLndvYmJsZVkgPSBmZXR0aS55ICsgKDEwICogZmV0dGkuc2NhbGFyKTtcblxuICAgICAgZmV0dGkudGlsdFNpbiA9IDA7XG4gICAgICBmZXR0aS50aWx0Q29zID0gMDtcbiAgICAgIGZldHRpLnJhbmRvbSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZldHRpLndvYmJsZSArPSBmZXR0aS53b2JibGVTcGVlZDtcbiAgICAgIGZldHRpLndvYmJsZVggPSBmZXR0aS54ICsgKCgxMCAqIGZldHRpLnNjYWxhcikgKiBNYXRoLmNvcyhmZXR0aS53b2JibGUpKTtcbiAgICAgIGZldHRpLndvYmJsZVkgPSBmZXR0aS55ICsgKCgxMCAqIGZldHRpLnNjYWxhcikgKiBNYXRoLnNpbihmZXR0aS53b2JibGUpKTtcblxuICAgICAgZmV0dGkudGlsdEFuZ2xlICs9IDAuMTtcbiAgICAgIGZldHRpLnRpbHRTaW4gPSBNYXRoLnNpbihmZXR0aS50aWx0QW5nbGUpO1xuICAgICAgZmV0dGkudGlsdENvcyA9IE1hdGguY29zKGZldHRpLnRpbHRBbmdsZSk7XG4gICAgICBmZXR0aS5yYW5kb20gPSBNYXRoLnJhbmRvbSgpICsgMjtcbiAgICB9XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSAoZmV0dGkudGljaysrKSAvIGZldHRpLnRvdGFsVGlja3M7XG5cbiAgICB2YXIgeDEgPSBmZXR0aS54ICsgKGZldHRpLnJhbmRvbSAqIGZldHRpLnRpbHRDb3MpO1xuICAgIHZhciB5MSA9IGZldHRpLnkgKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdFNpbik7XG4gICAgdmFyIHgyID0gZmV0dGkud29iYmxlWCArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0Q29zKTtcbiAgICB2YXIgeTIgPSBmZXR0aS53b2JibGVZICsgKGZldHRpLnJhbmRvbSAqIGZldHRpLnRpbHRTaW4pO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgZmV0dGkuY29sb3IuciArICcsICcgKyBmZXR0aS5jb2xvci5nICsgJywgJyArIGZldHRpLmNvbG9yLmIgKyAnLCAnICsgKDEgLSBwcm9ncmVzcykgKyAnKSc7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKGNhblVzZVBhdGhzICYmIGZldHRpLnNoYXBlLnR5cGUgPT09ICdwYXRoJyAmJiB0eXBlb2YgZmV0dGkuc2hhcGUucGF0aCA9PT0gJ3N0cmluZycgJiYgQXJyYXkuaXNBcnJheShmZXR0aS5zaGFwZS5tYXRyaXgpKSB7XG4gICAgICBjb250ZXh0LmZpbGwodHJhbnNmb3JtUGF0aDJEKFxuICAgICAgICBmZXR0aS5zaGFwZS5wYXRoLFxuICAgICAgICBmZXR0aS5zaGFwZS5tYXRyaXgsXG4gICAgICAgIGZldHRpLngsXG4gICAgICAgIGZldHRpLnksXG4gICAgICAgIE1hdGguYWJzKHgyIC0geDEpICogMC4xLFxuICAgICAgICBNYXRoLmFicyh5MiAtIHkxKSAqIDAuMSxcbiAgICAgICAgTWF0aC5QSSAvIDEwICogZmV0dGkud29iYmxlXG4gICAgICApKTtcbiAgICB9IGVsc2UgaWYgKGZldHRpLnNoYXBlLnR5cGUgPT09ICdiaXRtYXAnKSB7XG4gICAgICB2YXIgcm90YXRpb24gPSBNYXRoLlBJIC8gMTAgKiBmZXR0aS53b2JibGU7XG4gICAgICB2YXIgc2NhbGVYID0gTWF0aC5hYnMoeDIgLSB4MSkgKiAwLjE7XG4gICAgICB2YXIgc2NhbGVZID0gTWF0aC5hYnMoeTIgLSB5MSkgKiAwLjE7XG4gICAgICB2YXIgd2lkdGggPSBmZXR0aS5zaGFwZS5iaXRtYXAud2lkdGggKiBmZXR0aS5zY2FsYXI7XG4gICAgICB2YXIgaGVpZ2h0ID0gZmV0dGkuc2hhcGUuYml0bWFwLmhlaWdodCAqIGZldHRpLnNjYWxhcjtcblxuICAgICAgdmFyIG1hdHJpeCA9IG5ldyBET01NYXRyaXgoW1xuICAgICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVgsXG4gICAgICAgIE1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWCxcbiAgICAgICAgLU1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWSxcbiAgICAgICAgTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVZLFxuICAgICAgICBmZXR0aS54LFxuICAgICAgICBmZXR0aS55XG4gICAgICBdKTtcblxuICAgICAgLy8gYXBwbHkgdGhlIHRyYW5zZm9ybSBtYXRyaXggZnJvbSB0aGUgY29uZmV0dGkgc2hhcGVcbiAgICAgIG1hdHJpeC5tdWx0aXBseVNlbGYobmV3IERPTU1hdHJpeChmZXR0aS5zaGFwZS5tYXRyaXgpKTtcblxuICAgICAgdmFyIHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oYml0bWFwTWFwcGVyLnRyYW5zZm9ybShmZXR0aS5zaGFwZS5iaXRtYXApLCAnbm8tcmVwZWF0Jyk7XG4gICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShtYXRyaXgpO1xuXG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gKDEgLSBwcm9ncmVzcyk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KFxuICAgICAgICBmZXR0aS54IC0gKHdpZHRoIC8gMiksXG4gICAgICAgIGZldHRpLnkgLSAoaGVpZ2h0IC8gMiksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gMTtcbiAgICB9IGVsc2UgaWYgKGZldHRpLnNoYXBlID09PSAnY2lyY2xlJykge1xuICAgICAgY29udGV4dC5lbGxpcHNlID9cbiAgICAgICAgY29udGV4dC5lbGxpcHNlKGZldHRpLngsIGZldHRpLnksIE1hdGguYWJzKHgyIC0geDEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5hYnMoeTIgLSB5MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLlBJIC8gMTAgKiBmZXR0aS53b2JibGUsIDAsIDIgKiBNYXRoLlBJKSA6XG4gICAgICAgIGVsbGlwc2UoY29udGV4dCwgZmV0dGkueCwgZmV0dGkueSwgTWF0aC5hYnMoeDIgLSB4MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLmFicyh5MiAtIHkxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZSwgMCwgMiAqIE1hdGguUEkpO1xuICAgIH0gZWxzZSBpZiAoZmV0dGkuc2hhcGUgPT09ICdzdGFyJykge1xuICAgICAgdmFyIHJvdCA9IE1hdGguUEkgLyAyICogMztcbiAgICAgIHZhciBpbm5lclJhZGl1cyA9IDQgKiBmZXR0aS5zY2FsYXI7XG4gICAgICB2YXIgb3V0ZXJSYWRpdXMgPSA4ICogZmV0dGkuc2NhbGFyO1xuICAgICAgdmFyIHggPSBmZXR0aS54O1xuICAgICAgdmFyIHkgPSBmZXR0aS55O1xuICAgICAgdmFyIHNwaWtlcyA9IDU7XG4gICAgICB2YXIgc3RlcCA9IE1hdGguUEkgLyBzcGlrZXM7XG5cbiAgICAgIHdoaWxlIChzcGlrZXMtLSkge1xuICAgICAgICB4ID0gZmV0dGkueCArIE1hdGguY29zKHJvdCkgKiBvdXRlclJhZGl1cztcbiAgICAgICAgeSA9IGZldHRpLnkgKyBNYXRoLnNpbihyb3QpICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICByb3QgKz0gc3RlcDtcblxuICAgICAgICB4ID0gZmV0dGkueCArIE1hdGguY29zKHJvdCkgKiBpbm5lclJhZGl1cztcbiAgICAgICAgeSA9IGZldHRpLnkgKyBNYXRoLnNpbihyb3QpICogaW5uZXJSYWRpdXM7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICByb3QgKz0gc3RlcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5tb3ZlVG8oTWF0aC5mbG9vcihmZXR0aS54KSwgTWF0aC5mbG9vcihmZXR0aS55KSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKGZldHRpLndvYmJsZVgpLCBNYXRoLmZsb29yKHkxKSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKHgyKSwgTWF0aC5mbG9vcih5MikpO1xuICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5mbG9vcih4MSksIE1hdGguZmxvb3IoZmV0dGkud29iYmxlWSkpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG5cbiAgICByZXR1cm4gZmV0dGkudGljayA8IGZldHRpLnRvdGFsVGlja3M7XG4gIH1cblxuICBmdW5jdGlvbiBhbmltYXRlKGNhbnZhcywgZmV0dGlzLCByZXNpemVyLCBzaXplLCBkb25lKSB7XG4gICAgdmFyIGFuaW1hdGluZ0ZldHRpcyA9IGZldHRpcy5zbGljZSgpO1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGFuaW1hdGlvbkZyYW1lO1xuICAgIHZhciBkZXN0cm95O1xuXG4gICAgdmFyIHByb20gPSBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBmdW5jdGlvbiBvbkRvbmUoKSB7XG4gICAgICAgIGFuaW1hdGlvbkZyYW1lID0gZGVzdHJveSA9IG51bGw7XG5cbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICBiaXRtYXBNYXBwZXIuY2xlYXIoKTtcblxuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNXb3JrZXIgJiYgIShzaXplLndpZHRoID09PSB3b3JrZXJTaXplLndpZHRoICYmIHNpemUuaGVpZ2h0ID09PSB3b3JrZXJTaXplLmhlaWdodCkpIHtcbiAgICAgICAgICBzaXplLndpZHRoID0gY2FudmFzLndpZHRoID0gd29ya2VyU2l6ZS53aWR0aDtcbiAgICAgICAgICBzaXplLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSB3b3JrZXJTaXplLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2l6ZS53aWR0aCAmJiAhc2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICByZXNpemVyKGNhbnZhcyk7XG4gICAgICAgICAgc2l6ZS53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICBzaXplLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cbiAgICAgICAgYW5pbWF0aW5nRmV0dGlzID0gYW5pbWF0aW5nRmV0dGlzLmZpbHRlcihmdW5jdGlvbiAoZmV0dGkpIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRmV0dGkoY29udGV4dCwgZmV0dGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYW5pbWF0aW5nRmV0dGlzLmxlbmd0aCkge1xuICAgICAgICAgIGFuaW1hdGlvbkZyYW1lID0gcmFmLmZyYW1lKHVwZGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25Eb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uRnJhbWUgPSByYWYuZnJhbWUodXBkYXRlKTtcbiAgICAgIGRlc3Ryb3kgPSBvbkRvbmU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkRmV0dGlzOiBmdW5jdGlvbiAoZmV0dGlzKSB7XG4gICAgICAgIGFuaW1hdGluZ0ZldHRpcyA9IGFuaW1hdGluZ0ZldHRpcy5jb25jYXQoZmV0dGlzKTtcblxuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgIH0sXG4gICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgIHByb21pc2U6IHByb20sXG4gICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICByYWYuY2FuY2VsKGFuaW1hdGlvbkZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXN0cm95KSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZldHRpQ2Fubm9uKGNhbnZhcywgZ2xvYmFsT3B0cykge1xuICAgIHZhciBpc0xpYkNhbnZhcyA9ICFjYW52YXM7XG4gICAgdmFyIGFsbG93UmVzaXplID0gISFwcm9wKGdsb2JhbE9wdHMgfHwge30sICdyZXNpemUnKTtcbiAgICB2YXIgaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgdmFyIGdsb2JhbERpc2FibGVGb3JSZWR1Y2VkTW90aW9uID0gcHJvcChnbG9iYWxPcHRzLCAnZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24nLCBCb29sZWFuKTtcbiAgICB2YXIgc2hvdWxkVXNlV29ya2VyID0gY2FuVXNlV29ya2VyICYmICEhcHJvcChnbG9iYWxPcHRzIHx8IHt9LCAndXNlV29ya2VyJyk7XG4gICAgdmFyIHdvcmtlciA9IHNob3VsZFVzZVdvcmtlciA/IGdldFdvcmtlcigpIDogbnVsbDtcbiAgICB2YXIgcmVzaXplciA9IGlzTGliQ2FudmFzID8gc2V0Q2FudmFzV2luZG93U2l6ZSA6IHNldENhbnZhc1JlY3RTaXplO1xuICAgIHZhciBpbml0aWFsaXplZCA9IChjYW52YXMgJiYgd29ya2VyKSA/ICEhY2FudmFzLl9fY29uZmV0dGlfaW5pdGlhbGl6ZWQgOiBmYWxzZTtcbiAgICB2YXIgcHJlZmVyTGVzc01vdGlvbiA9IHR5cGVvZiBtYXRjaE1lZGlhID09PSAnZnVuY3Rpb24nICYmIG1hdGNoTWVkaWEoJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uKScpLm1hdGNoZXM7XG4gICAgdmFyIGFuaW1hdGlvbk9iajtcblxuICAgIGZ1bmN0aW9uIGZpcmVMb2NhbChvcHRpb25zLCBzaXplLCBkb25lKSB7XG4gICAgICB2YXIgcGFydGljbGVDb3VudCA9IHByb3Aob3B0aW9ucywgJ3BhcnRpY2xlQ291bnQnLCBvbmx5UG9zaXRpdmVJbnQpO1xuICAgICAgdmFyIGFuZ2xlID0gcHJvcChvcHRpb25zLCAnYW5nbGUnLCBOdW1iZXIpO1xuICAgICAgdmFyIHNwcmVhZCA9IHByb3Aob3B0aW9ucywgJ3NwcmVhZCcsIE51bWJlcik7XG4gICAgICB2YXIgc3RhcnRWZWxvY2l0eSA9IHByb3Aob3B0aW9ucywgJ3N0YXJ0VmVsb2NpdHknLCBOdW1iZXIpO1xuICAgICAgdmFyIGRlY2F5ID0gcHJvcChvcHRpb25zLCAnZGVjYXknLCBOdW1iZXIpO1xuICAgICAgdmFyIGdyYXZpdHkgPSBwcm9wKG9wdGlvbnMsICdncmF2aXR5JywgTnVtYmVyKTtcbiAgICAgIHZhciBkcmlmdCA9IHByb3Aob3B0aW9ucywgJ2RyaWZ0JywgTnVtYmVyKTtcbiAgICAgIHZhciBjb2xvcnMgPSBwcm9wKG9wdGlvbnMsICdjb2xvcnMnLCBjb2xvcnNUb1JnYik7XG4gICAgICB2YXIgdGlja3MgPSBwcm9wKG9wdGlvbnMsICd0aWNrcycsIE51bWJlcik7XG4gICAgICB2YXIgc2hhcGVzID0gcHJvcChvcHRpb25zLCAnc2hhcGVzJyk7XG4gICAgICB2YXIgc2NhbGFyID0gcHJvcChvcHRpb25zLCAnc2NhbGFyJyk7XG4gICAgICB2YXIgZmxhdCA9ICEhcHJvcChvcHRpb25zLCAnZmxhdCcpO1xuICAgICAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbihvcHRpb25zKTtcblxuICAgICAgdmFyIHRlbXAgPSBwYXJ0aWNsZUNvdW50O1xuICAgICAgdmFyIGZldHRpcyA9IFtdO1xuXG4gICAgICB2YXIgc3RhcnRYID0gY2FudmFzLndpZHRoICogb3JpZ2luLng7XG4gICAgICB2YXIgc3RhcnRZID0gY2FudmFzLmhlaWdodCAqIG9yaWdpbi55O1xuXG4gICAgICB3aGlsZSAodGVtcC0tKSB7XG4gICAgICAgIGZldHRpcy5wdXNoKFxuICAgICAgICAgIHJhbmRvbVBoeXNpY3Moe1xuICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgeTogc3RhcnRZLFxuICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgc3ByZWFkOiBzcHJlYWQsXG4gICAgICAgICAgICBzdGFydFZlbG9jaXR5OiBzdGFydFZlbG9jaXR5LFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yc1t0ZW1wICUgY29sb3JzLmxlbmd0aF0sXG4gICAgICAgICAgICBzaGFwZTogc2hhcGVzW3JhbmRvbUludCgwLCBzaGFwZXMubGVuZ3RoKV0sXG4gICAgICAgICAgICB0aWNrczogdGlja3MsXG4gICAgICAgICAgICBkZWNheTogZGVjYXksXG4gICAgICAgICAgICBncmF2aXR5OiBncmF2aXR5LFxuICAgICAgICAgICAgZHJpZnQ6IGRyaWZ0LFxuICAgICAgICAgICAgc2NhbGFyOiBzY2FsYXIsXG4gICAgICAgICAgICBmbGF0OiBmbGF0XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgaGF2ZSBhIHByZXZpb3VzIGNhbnZhcyBhbHJlYWR5IGFuaW1hdGluZyxcbiAgICAgIC8vIGFkZCB0byBpdFxuICAgICAgaWYgKGFuaW1hdGlvbk9iaikge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uT2JqLmFkZEZldHRpcyhmZXR0aXMpO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25PYmogPSBhbmltYXRlKGNhbnZhcywgZmV0dGlzLCByZXNpemVyLCBzaXplICwgZG9uZSk7XG5cbiAgICAgIHJldHVybiBhbmltYXRpb25PYmoucHJvbWlzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJlKG9wdGlvbnMpIHtcbiAgICAgIHZhciBkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiA9IGdsb2JhbERpc2FibGVGb3JSZWR1Y2VkTW90aW9uIHx8IHByb3Aob3B0aW9ucywgJ2Rpc2FibGVGb3JSZWR1Y2VkTW90aW9uJywgQm9vbGVhbik7XG4gICAgICB2YXIgekluZGV4ID0gcHJvcChvcHRpb25zLCAnekluZGV4JywgTnVtYmVyKTtcblxuICAgICAgaWYgKGRpc2FibGVGb3JSZWR1Y2VkTW90aW9uICYmIHByZWZlckxlc3NNb3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMaWJDYW52YXMgJiYgYW5pbWF0aW9uT2JqKSB7XG4gICAgICAgIC8vIHVzZSBleGlzdGluZyBjYW52YXMgZnJvbSBpbi1wcm9ncmVzcyBhbmltYXRpb25cbiAgICAgICAgY2FudmFzID0gYW5pbWF0aW9uT2JqLmNhbnZhcztcbiAgICAgIH0gZWxzZSBpZiAoaXNMaWJDYW52YXMgJiYgIWNhbnZhcykge1xuICAgICAgICAvLyBjcmVhdGUgYW5kIGluaXRpYWxpemUgYSBuZXcgY2FudmFzXG4gICAgICAgIGNhbnZhcyA9IGdldENhbnZhcyh6SW5kZXgpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1Jlc2l6ZSAmJiAhaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2l6ZSBvZiBhIHVzZXItc3VwcGxpZWQgY2FudmFzXG4gICAgICAgIHJlc2l6ZXIoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpemUgPSB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcblxuICAgICAgaWYgKHdvcmtlciAmJiAhaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgd29ya2VyLmluaXQoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgIGNhbnZhcy5fX2NvbmZldHRpX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgICAvLyBUT0RPIHRoaXMgcmVhbGx5IHNob3VsZG4ndCBiZSBpbW1lZGlhdGUsIGJlY2F1c2UgaXQgaXMgZXhwZW5zaXZlXG4gICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIWlzTGliQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXNpemVyKG9iaik7XG5cbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgcmVzaXplOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBvYmoud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogb2JqLmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbid0IGFjdHVhbGx5IHF1ZXJ5IHRoZSBzaXplIGhlcmUsIHNpbmNlIHRoaXNcbiAgICAgICAgLy8gY2FuIGV4ZWN1dGUgZnJlcXVlbnRseSBhbmQgcmFwaWRseVxuICAgICAgICBzaXplLndpZHRoID0gc2l6ZS5oZWlnaHQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICBhbmltYXRpb25PYmogPSBudWxsO1xuXG4gICAgICAgIGlmIChhbGxvd1Jlc2l6ZSkge1xuICAgICAgICAgIGhhc1Jlc2l6ZUV2ZW50UmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNMaWJDYW52YXMgJiYgY2FudmFzKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW52YXMgPSBudWxsO1xuICAgICAgICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93UmVzaXplICYmICFoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQpIHtcbiAgICAgICAgaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuIHdvcmtlci5maXJlKG9wdGlvbnMsIHNpemUsIGRvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlyZUxvY2FsKG9wdGlvbnMsIHNpemUsIGRvbmUpO1xuICAgIH1cblxuICAgIGZpcmUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgIHdvcmtlci5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0aW9uT2JqKSB7XG4gICAgICAgIGFuaW1hdGlvbk9iai5yZXNldCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZmlyZTtcbiAgfVxuXG4gIC8vIE1ha2UgZGVmYXVsdCBleHBvcnQgbGF6eSB0byBkZWZlciB3b3JrZXIgY3JlYXRpb24gdW50aWwgY2FsbGVkLlxuICB2YXIgZGVmYXVsdEZpcmU7XG4gIGZ1bmN0aW9uIGdldERlZmF1bHRGaXJlKCkge1xuICAgIGlmICghZGVmYXVsdEZpcmUpIHtcbiAgICAgIGRlZmF1bHRGaXJlID0gY29uZmV0dGlDYW5ub24obnVsbCwgeyB1c2VXb3JrZXI6IHRydWUsIHJlc2l6ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRGaXJlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aDJEKHBhdGhTdHJpbmcsIHBhdGhNYXRyaXgsIHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbikge1xuICAgIHZhciBwYXRoMmQgPSBuZXcgUGF0aDJEKHBhdGhTdHJpbmcpO1xuXG4gICAgdmFyIHQxID0gbmV3IFBhdGgyRCgpO1xuICAgIHQxLmFkZFBhdGgocGF0aDJkLCBuZXcgRE9NTWF0cml4KHBhdGhNYXRyaXgpKTtcblxuICAgIHZhciB0MiA9IG5ldyBQYXRoMkQoKTtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTU1hdHJpeC9ET01NYXRyaXhcbiAgICB0Mi5hZGRQYXRoKHQxLCBuZXcgRE9NTWF0cml4KFtcbiAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWCxcbiAgICAgIE1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWCxcbiAgICAgIC1NYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICB4LFxuICAgICAgeVxuICAgIF0pKTtcblxuICAgIHJldHVybiB0MjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXBlRnJvbVBhdGgocGF0aERhdGEpIHtcbiAgICBpZiAoIWNhblVzZVBhdGhzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggY29uZmV0dGkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgfVxuXG4gICAgdmFyIHBhdGgsIG1hdHJpeDtcblxuICAgIGlmICh0eXBlb2YgcGF0aERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXRoID0gcGF0aERhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBwYXRoRGF0YS5wYXRoO1xuICAgICAgbWF0cml4ID0gcGF0aERhdGEubWF0cml4O1xuICAgIH1cblxuICAgIHZhciBwYXRoMmQgPSBuZXcgUGF0aDJEKHBhdGgpO1xuICAgIHZhciB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIHRlbXBDdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBpZiAoIW1hdHJpeCkge1xuICAgICAgLy8gYXR0ZW1wdCB0byBmaWd1cmUgb3V0IHRoZSB3aWR0aCBvZiB0aGUgcGF0aCwgdXAgdG8gMTAwMHgxMDAwXG4gICAgICB2YXIgbWF4U2l6ZSA9IDEwMDA7XG4gICAgICB2YXIgbWluWCA9IG1heFNpemU7XG4gICAgICB2YXIgbWluWSA9IG1heFNpemU7XG4gICAgICB2YXIgbWF4WCA9IDA7XG4gICAgICB2YXIgbWF4WSA9IDA7XG4gICAgICB2YXIgd2lkdGgsIGhlaWdodDtcblxuICAgICAgLy8gZG8gc29tZSBsaW5lIHNraXBwaW5nLi4uIHRoaXMgaXMgZmFzdGVyIHRoYW4gY2hlY2tpbmdcbiAgICAgIC8vIGV2ZXJ5IHBpeGVsIGFuZCB3aWxsIGJlIG1vc3RseSBzdGlsbCBjb3JyZWN0XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1heFNpemU7IHggKz0gMikge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG1heFNpemU7IHkgKz0gMikge1xuICAgICAgICAgIGlmICh0ZW1wQ3R4LmlzUG9pbnRJblBhdGgocGF0aDJkLCB4LCB5LCAnbm9uemVybycpKSB7XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgICBoZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgICAgdmFyIG1heERlc2lyZWRTaXplID0gMTA7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihtYXhEZXNpcmVkU2l6ZS93aWR0aCwgbWF4RGVzaXJlZFNpemUvaGVpZ2h0KTtcblxuICAgICAgbWF0cml4ID0gW1xuICAgICAgICBzY2FsZSwgMCwgMCwgc2NhbGUsXG4gICAgICAgIC1NYXRoLnJvdW5kKCh3aWR0aC8yKSArIG1pblgpICogc2NhbGUsXG4gICAgICAgIC1NYXRoLnJvdW5kKChoZWlnaHQvMikgKyBtaW5ZKSAqIHNjYWxlXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAncGF0aCcsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgbWF0cml4OiBtYXRyaXhcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcGVGcm9tVGV4dCh0ZXh0RGF0YSkge1xuICAgIHZhciB0ZXh0LFxuICAgICAgICBzY2FsYXIgPSAxLFxuICAgICAgICBjb2xvciA9ICcjMDAwMDAwJyxcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vbm9sYW5sYXdzb24uY29tLzIwMjIvMDQvMDgvdGhlLXN0cnVnZ2xlLW9mLXVzaW5nLW5hdGl2ZS1lbW9qaS1vbi10aGUtd2ViL1xuICAgICAgICBmb250RmFtaWx5ID0gJ1wiQXBwbGUgQ29sb3IgRW1vamlcIiwgXCJTZWdvZSBVSSBFbW9qaVwiLCBcIlNlZ29lIFVJIFN5bWJvbFwiLCBcIk5vdG8gQ29sb3IgRW1vamlcIiwgXCJFbW9qaU9uZSBDb2xvclwiLCBcIkFuZHJvaWQgRW1vamlcIiwgXCJUd2Vtb2ppIE1vemlsbGFcIiwgXCJzeXN0ZW0gZW1vamlcIiwgc2Fucy1zZXJpZic7XG5cbiAgICBpZiAodHlwZW9mIHRleHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdGV4dCA9IHRleHREYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gdGV4dERhdGEudGV4dDtcbiAgICAgIHNjYWxhciA9ICdzY2FsYXInIGluIHRleHREYXRhID8gdGV4dERhdGEuc2NhbGFyIDogc2NhbGFyO1xuICAgICAgZm9udEZhbWlseSA9ICdmb250RmFtaWx5JyBpbiB0ZXh0RGF0YSA/IHRleHREYXRhLmZvbnRGYW1pbHkgOiBmb250RmFtaWx5O1xuICAgICAgY29sb3IgPSAnY29sb3InIGluIHRleHREYXRhID8gdGV4dERhdGEuY29sb3IgOiBjb2xvcjtcbiAgICB9XG5cbiAgICAvLyBhbGwgb3RoZXIgY29uZmV0dGkgYXJlIDEwIHBpeGVscyxcbiAgICAvLyBzbyB0aGlzIHBpeGVsIHNpemUgaXMgdGhlIGRlLWZhY3RvIDEwMCUgc2NhbGUgY29uZmV0dGlcbiAgICB2YXIgZm9udFNpemUgPSAxMCAqIHNjYWxhcjtcbiAgICB2YXIgZm9udCA9ICcnICsgZm9udFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG5cbiAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhmb250U2l6ZSwgZm9udFNpemUpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICB2YXIgc2l6ZSA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoc2l6ZS5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0ICsgc2l6ZS5hY3R1YWxCb3VuZGluZ0JveExlZnQpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLmNlaWwoc2l6ZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIHNpemUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KTtcblxuICAgIHZhciBwYWRkaW5nID0gMjtcbiAgICB2YXIgeCA9IHNpemUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0ICsgcGFkZGluZztcbiAgICB2YXIgeSA9IHNpemUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBwYWRkaW5nO1xuICAgIHdpZHRoICs9IHBhZGRpbmcgKyBwYWRkaW5nO1xuICAgIGhlaWdodCArPSBwYWRkaW5nICsgcGFkZGluZztcblxuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcblxuICAgIHZhciBzY2FsZSA9IDEgLyBzY2FsYXI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2JpdG1hcCcsXG4gICAgICAvLyBUT0RPIHRoZXNlIHByb2JhYmx5IG5lZWQgdG8gYmUgdHJhbnNmZXJlZCBmb3Igd29ya2Vyc1xuICAgICAgYml0bWFwOiBjYW52YXMudHJhbnNmZXJUb0ltYWdlQml0bWFwKCksXG4gICAgICBtYXRyaXg6IFtzY2FsZSwgMCwgMCwgc2NhbGUsIC13aWR0aCAqIHNjYWxlIC8gMiwgLWhlaWdodCAqIHNjYWxlIC8gMl1cbiAgICB9O1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdEZpcmUoKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIGdldERlZmF1bHRGaXJlKCkucmVzZXQoKTtcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gY29uZmV0dGlDYW5ub247XG4gIG1vZHVsZS5leHBvcnRzLnNoYXBlRnJvbVBhdGggPSBzaGFwZUZyb21QYXRoO1xuICBtb2R1bGUuZXhwb3J0cy5zaGFwZUZyb21UZXh0ID0gc2hhcGVGcm9tVGV4dDtcbn0oKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIHJldHVybiB0aGlzIHx8IHt9O1xufSkoKSwgbW9kdWxlLCBmYWxzZSkpO1xuXG4vLyBlbmQgc291cmNlIGNvbnRlbnRcblxuZXhwb3J0IGRlZmF1bHQgbW9kdWxlLmV4cG9ydHM7XG5leHBvcnQgdmFyIGNyZWF0ZSA9IG1vZHVsZS5leHBvcnRzLmNyZWF0ZTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJtYWluIiwiZ2xvYmFsIiwiaXNXb3JrZXIiLCJ3b3JrZXJTaXplIiwiY2FuVXNlV29ya2VyIiwiV29ya2VyIiwiQmxvYiIsIlByb21pc2UiLCJPZmZzY3JlZW5DYW52YXMiLCJPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQiLCJIVE1MQ2FudmFzRWxlbWVudCIsInByb3RvdHlwZSIsInRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiY2FuVXNlUGF0aHMiLCJQYXRoMkQiLCJET01NYXRyaXgiLCJjYW5EcmF3Qml0bWFwIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxSZWN0IiwiYml0bWFwIiwidHJhbnNmZXJUb0ltYWdlQml0bWFwIiwiY3JlYXRlUGF0dGVybiIsImUiLCJub29wIiwicHJvbWlzZSIsImZ1bmMiLCJNb2R1bGVQcm9taXNlIiwiZXhwb3J0cyIsIlByb20iLCJiaXRtYXBNYXBwZXIiLCJza2lwVHJhbnNmb3JtIiwibWFwIiwidHJhbnNmb3JtIiwiaGFzIiwiZ2V0Iiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3SW1hZ2UiLCJzZXQiLCJjbGVhciIsIk1hcCIsInJhZiIsIlRJTUUiLCJNYXRoIiwiZmxvb3IiLCJmcmFtZSIsImNhbmNlbCIsImZyYW1lcyIsImxhc3RGcmFtZVRpbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNiIiwiaWQiLCJyYW5kb20iLCJvbkZyYW1lIiwidGltZSIsInNldFRpbWVvdXQiLCJ0aW1lciIsImNsZWFyVGltZW91dCIsImdldFdvcmtlciIsIndvcmtlciIsInByb20iLCJyZXNvbHZlcyIsImRlY29yYXRlIiwiZXhlY3V0ZSIsIm9wdGlvbnMiLCJjYWxsYmFjayIsInBvc3RNZXNzYWdlIiwiaW5pdCIsImluaXRXb3JrZXIiLCJvZmZzY3JlZW4iLCJmaXJlIiwiZmlyZVdvcmtlciIsInNpemUiLCJkb25lIiwidG9TdHJpbmciLCJzbGljZSIsInJlc29sdmUiLCJ3b3JrZXJEb25lIiwibXNnIiwiZGF0YSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiYmluZCIsInJlc2V0IiwicmVzZXRXb3JrZXIiLCJjb2RlIiwiam9pbiIsImNvbnNvbGUiLCJ3YXJuIiwiZGVmYXVsdHMiLCJwYXJ0aWNsZUNvdW50IiwiYW5nbGUiLCJzcHJlYWQiLCJzdGFydFZlbG9jaXR5IiwiZGVjYXkiLCJncmF2aXR5IiwiZHJpZnQiLCJ0aWNrcyIsIngiLCJ5Iiwic2hhcGVzIiwiekluZGV4IiwiY29sb3JzIiwiZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24iLCJzY2FsYXIiLCJjb252ZXJ0IiwidmFsIiwiaXNPayIsInVuZGVmaW5lZCIsInByb3AiLCJuYW1lIiwib25seVBvc2l0aXZlSW50IiwibnVtYmVyIiwicmFuZG9tSW50IiwibWluIiwibWF4IiwidG9EZWNpbWFsIiwic3RyIiwicGFyc2VJbnQiLCJjb2xvcnNUb1JnYiIsImhleFRvUmdiIiwiU3RyaW5nIiwicmVwbGFjZSIsImxlbmd0aCIsInIiLCJzdWJzdHJpbmciLCJnIiwiYiIsImdldE9yaWdpbiIsIm9yaWdpbiIsIk9iamVjdCIsIk51bWJlciIsInNldENhbnZhc1dpbmRvd1NpemUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2V0Q2FudmFzUmVjdFNpemUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2FudmFzIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwicG9pbnRlckV2ZW50cyIsImVsbGlwc2UiLCJjb250ZXh0IiwicmFkaXVzWCIsInJhZGl1c1kiLCJyb3RhdGlvbiIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImFudGlDbG9ja3dpc2UiLCJzYXZlIiwidHJhbnNsYXRlIiwicm90YXRlIiwic2NhbGUiLCJhcmMiLCJyZXN0b3JlIiwicmFuZG9tUGh5c2ljcyIsIm9wdHMiLCJyYWRBbmdsZSIsIlBJIiwicmFkU3ByZWFkIiwid29iYmxlIiwid29iYmxlU3BlZWQiLCJ2ZWxvY2l0eSIsImFuZ2xlMkQiLCJ0aWx0QW5nbGUiLCJjb2xvciIsInNoYXBlIiwidGljayIsInRvdGFsVGlja3MiLCJ0aWx0U2luIiwidGlsdENvcyIsIndvYmJsZVgiLCJ3b2JibGVZIiwib3ZhbFNjYWxhciIsImZsYXQiLCJ1cGRhdGVGZXR0aSIsImZldHRpIiwiY29zIiwic2luIiwicHJvZ3Jlc3MiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImZpbGxTdHlsZSIsImJlZ2luUGF0aCIsInR5cGUiLCJwYXRoIiwiQXJyYXkiLCJpc0FycmF5IiwibWF0cml4IiwiZmlsbCIsInRyYW5zZm9ybVBhdGgyRCIsImFicyIsInNjYWxlWCIsInNjYWxlWSIsIm11bHRpcGx5U2VsZiIsInBhdHRlcm4iLCJzZXRUcmFuc2Zvcm0iLCJnbG9iYWxBbHBoYSIsInJvdCIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJzcGlrZXMiLCJzdGVwIiwibGluZVRvIiwibW92ZVRvIiwiY2xvc2VQYXRoIiwiYW5pbWF0ZSIsImZldHRpcyIsInJlc2l6ZXIiLCJhbmltYXRpbmdGZXR0aXMiLCJhbmltYXRpb25GcmFtZSIsImRlc3Ryb3kiLCJvbkRvbmUiLCJjbGVhclJlY3QiLCJ1cGRhdGUiLCJmaWx0ZXIiLCJhZGRGZXR0aXMiLCJjb25jYXQiLCJjb25mZXR0aUNhbm5vbiIsImdsb2JhbE9wdHMiLCJpc0xpYkNhbnZhcyIsImFsbG93UmVzaXplIiwiaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkIiwiZ2xvYmFsRGlzYWJsZUZvclJlZHVjZWRNb3Rpb24iLCJCb29sZWFuIiwic2hvdWxkVXNlV29ya2VyIiwiaW5pdGlhbGl6ZWQiLCJfX2NvbmZldHRpX2luaXRpYWxpemVkIiwicHJlZmVyTGVzc01vdGlvbiIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiYW5pbWF0aW9uT2JqIiwiZmlyZUxvY2FsIiwidGVtcCIsInN0YXJ0WCIsInN0YXJ0WSIsInB1c2giLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJvblJlc2l6ZSIsIm9iaiIsInJlc2l6ZSIsImNvbnRhaW5zIiwicmVtb3ZlQ2hpbGQiLCJkZWZhdWx0RmlyZSIsImdldERlZmF1bHRGaXJlIiwidXNlV29ya2VyIiwicGF0aFN0cmluZyIsInBhdGhNYXRyaXgiLCJwYXRoMmQiLCJ0MSIsImFkZFBhdGgiLCJ0MiIsInNoYXBlRnJvbVBhdGgiLCJwYXRoRGF0YSIsIkVycm9yIiwidGVtcENhbnZhcyIsInRlbXBDdHgiLCJtYXhTaXplIiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImlzUG9pbnRJblBhdGgiLCJtYXhEZXNpcmVkU2l6ZSIsInJvdW5kIiwic2hhcGVGcm9tVGV4dCIsInRleHREYXRhIiwidGV4dCIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnQiLCJtZWFzdXJlVGV4dCIsImNlaWwiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJwYWRkaW5nIiwiZmlsbFRleHQiLCJhcHBseSIsImFyZ3VtZW50cyIsImNyZWF0ZSIsIndpbmRvdyIsInNlbGYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs\n");

/***/ })

};
;